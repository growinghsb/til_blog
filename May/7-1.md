# 인터페이스 정리     
* 인터페이스를 한 번 정리해 보려고 한다. 뭔가 굉장히 어렵게만     
  느껴졌던 인터페이스가 순수 추상클래스라는 것을 듣고 너무    
  명확해졌고, 확 와닿았다. 어쨋든 추상클래스가 뭔지 안다.    
  그리고 추상메서드 역시 뭔지 알고 있다. 그래서 그런지 인터페이스의    
  이해가 굉장히 쉬웠고 확실히 언제 사용해야 할 지 느낌이 왔다.          
  일단 왜 추상클래스로는 부족했는지를 알아보고, 인터페이스가 이를       
  어떻게 해결했는지 한 번 알아보겠다.     
***
* 일단 추상클래스로 다형적 기능을 이용하려면 부모추상클래스를      
  이용 하는 것이 가장 일반적일 것이다. 즉, 부모추상클래스 타입의      
  참조변수를 통해 오버라이딩한 메서드를 호출하는 것이 될 것이다.    
  이는 비효율이 발생한다. 단순히 메서드 하나 호출하자고,        
  객체를 가져다 사용하는 것이기 때문이다.(참조변수에는 메모리주소가        
  전달되기 때문에 원본이 전달된다.)       
  
  또 다중상속이 불가능하다는 점이다. 기본적으로 자바에서는 다이아몬드     
  상속 문제나 여러 문제로 인해 다중상속이 불가능하다.       
  추상클래스 역시 extends 키워드를 사용해 상속 받기 때문에       
  해당 추상클래스를 상속 받으면 다른 클래스를 상속받을 수 없게 된다.     
  다중상속이 분명 단점이 있지만 장점 역시 있다. 내가 필요한 기능을     
  여러 부모로부터 상속 받으며, 코드의 중복을 줄이고 상황에 맞게      
  유연하게 대처하는 프로그램을 만들 수 있는데 이 가능성을 아예      
  차단하는 것이 된다.      
  
* 위 같은 문제? 단점을 인터페이스를 통해 극복할 수 있다.      
  일단 인터페이스는 추상클래스와 다르게 멤버변수와 멤버 메서드를     
  가지지 않는다. 오직 추상메서드만 가지게 된다. 그렇게 됨으로써    
  자연스럽게 인터페이스는 인스턴스의 생성이 불가능 해진다.    
  또한 이를 상속(정확히는 implements 구현이라 한다.) 받는      
  자식 클래스에서 추상메서드를 구현할 수 있도록 컴파일러가     
  강제하게 된다. 이렇게 되면 추상클래스의 장점은 전부 가지면서     
  오직 기능만 정의하는, 효율적인 참조변수 타입을 가질 수 있는 것이다.      
  
  즉 인터페이스는 오직 추상메서드만 정의할 수 있고, 가지고 있으며,      
  인스턴스의 생성이 불가능 하고, 인터페이스를 상속 받은 자식클래스에서는        
  인터페이스의 모든 추상메서드를 구현하도록 강제하게 된다.       
  이게 순수추상클래스라고 불리우는 이유이다. 추상클래스와 굉장히 비슷하다.      
  
* 그럼 이렇게 똑같기만 하면 조금 무겁긴 하지만 일반 메서드도 사용할 수 있는      
  추상클래스를 사용하는 것이 좀 더 나아보인다. 뭐, 일리는 있다. 하지만      
  지금부터 인터페이스만의 조금 특별한 기능을 적어보겠다.       
  
  일단 다중상속이 가능하다. 즉 implements 인터페이스1, 인터페이스2 이렇게     
  다중상속이 가능하고, 공통된 기능만 가지고 있는 인터페이스 여러개를 조합해       
  강력한 자식클래스를 만들 수 있다는 이야기이다. 그럼 다중상속의 문제를      
  어떻게 해결 해냈을까?      
  
  일단 다중상속의 가장 대표적인 문제는 다이아몬드 상속 문젠데 이 과정에서      
  두 부모에 공통된 메서드 시그니처를 가진 메서드를 호출 했을 때(오버라이딩      
  하지 않고 자식클래스 참조변수를 통해서) 분명 부모마다 서로 다른 구현을    
  하고 있을 것인데 어떤 메서드를 호출할 지 어떻게 알 수 있지? 라는 문제다.       
  이 부분을 인터페이스가 해결할 수 있다. 아니 해결한다기 보다는 그냥     
  가지고 있는 성질 때문에 이런 문제가 발생하지 않는다고 보는 것이 더      
  맞을 거 같다. 일단 인터페이스가 가진 모든 메서드는 추상메서드이기 때문에      
  실행될 일이 없다. 실행되려면 자식클래스에서 오버라이딩 후 실행된다.      
  이 때 시그니처가 같은 메서드는 하나만 오버라이딩 해도 된다. 어짜피     
  구현은 자식클래스에서 진행되기 때문에 어떤 참조변수 타입이라도(인터페이스1이든      
  인터페이스2든 자식 자기자신이든) 그냥 오버라이딩 되어 있는 메서드만       
  실행시키면 된다. 그렇기 때문에 애초에 이 문제에서 자유로울 수 있는 것이다.     
  
  이게 가장 큰 장점이며, 다형성의 가장 큰 기능인 하나의 명령(메서드)으로        
  각기 다른 실행을 할 수 있는 것을 훌륭하게 충족시킨다.        
  이러한 이유로 인터페이스를 사용한다. 인터페이스를 사용하는 경우를 보면      
  인터페이스에 공통적인 기능만 정의해둔 뒤, 같은 행동을 하지만 구현 방식이나      
  실행 방식이 다른 클래스들이 상속 받아 다형적 기능을 이용하게 된다.     
  이 때 등장하는 것이 늦은 바인딩이다. 즉, 실행시점에 어떤 객체의 메서드가     
  실행될 지 결정 되는 것이다. 이런 늦은 바인딩으로 해당 구체클래스(자식클래스)      
  를 이용하는 클라이언트 객체들이 인터페이스에만 의존할 수 있게 되고(의존한다는 것은         
  객체를 사용하는 것과 같다. new 키워드롤 생성하든, 매개변수로 받든 협력을 위해      
  사용하는 것과 같다.) 결국 구체적인 구현이 변경되도, 인터페이스만 의존하기 때문에      
  확장에는 열려 있고, 수정에는 닫혀 있는 ocp 원칙을 지키는 프로그램을 만들 수      
  있게 된다.      
***
* 뒤에는 그냥 인터페이스를 사용하면 좋은 장점에 대해 잠깐 말해봤다.     
  아마 가장 큰 이유는 구체클래스를 몰라도 되는 것이 아닐까?     
  그렇게 됨으로써 ocp 원칙을 지키며, 유연한 프로그램을 만들 수     
  있게 된다. 이건 좀 뒤에 다시 다룰 이야기이니 이정도만 해야겠다.     
  
  쨋든 인터페이스는 무조건 public 추상 메서드만 가질 수 있고,      
  (public 만 가질 수 있는 이유는 추상메서드가 public 이 아니면     
  어떻게 사용할 것인가? protected 여도 될 거 같긴 한데..흐음)       
  추상클래스 처럼 인스턴스의 생성이 불가능 하며, 다중상속이 가능하기에      
  공통된 기능을 모아두고, 다형성을 이용하기 위해 사용한다. 라는 것이다.     
***
그럼 오늘은 이만 줄여야겠다! 주제가 있을 때 마다 정리하자.     
매일 하는 것은 시간이 좀 걸리고, 매일 새로운 주제를     
정리할만큼 가벼운 내용들은 아니기 때문이다!
  
  
  
