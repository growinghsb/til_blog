# 상속에서의 다형성과 추상클래스, 추상 메서드 정리     
* 제목에 뭘 정리할 지 썼으니 바로 정리해 봐야겠다.     
  일단 상속에서의 다형성이라니, 상속은 상속이고,    
  다형성은 다형성이 아니던가? 이렇게 나눈 이유는    
  인터페이스를 통한 다형성과 조금은 다른 성질이기 때문에     
  이렇게 나눠 보았다. 그럼 상속에서의 다형성 부터 정리해보겠다.     
***    
* 일단 다형성이 뭔지 알아야 한다. 다형성이란 다양한 형태를 할 수 있는     
  것. 이라고 생각하고 싶다. 다양한 형태로 변할 수 있는 것이라고 봐도     
  좋을 거 같다. 이는 다형성, polymorphysm 을 해석한 것인데 실제     
  코드에서도 하나의 부모 타입 참조변수로 여러 자식들의 실제 객체의 참조값을       
  저장하기 때문이다. 상속 관계에 있는 자식 클래스들은 부모 타입 참조 변수로         
  객체를 생성해 참조를 전달할 수 있다. 참조변수 타입과 실제 생성된 객체 참조의    
  타입이 서로 다른데 참조가 가능하다. 이게 다형성이다. 부모 타입 참조 변수는    
  자식 타입 참조를 저장할 수 있다. 여러 자식 모두. 그렇기 때문에 여러 다양한    
  형태로 변할 수 있다고 하는 것이다.     
  
  그럼 상속에서의 다형성은 무엇인가?    
  1. 상속의 경우 부모, 자식이 명확히 구분되고,      
     부모 타입 참조변수로 자식 타입의 참조를    
     저장할 수 있다.      
     
  2. 이렇게 저장한 참조는 기본적으로는 부모 자신의 필드와 메서드에만    
     접근할 수 있다. 하지만 오버라이딩을 통해 부모 클래스의 메서드를     
     시그니처는 그대로 유지한 채 구현부만 바꿔 재정의 한다면 부모 클래스    
     타입의 참조변수로도 자식 클래스에 있는 메서드를 실행할 수 있다.     
     오버라이딩 했기 때문에 자식 클래스에 있는 메서드에 접근할 수 있게    
     되는 것이다. 오버라이딩 한 메서드에 한해서 적용된다.       
     
  이렇게 두 가지 장점이 있다. 이 두 가지를 사용하면 상속이 단지 중복된       
  코드를 재사용 하는 것을 넘어서 굉장히 강력하게, 또 유연하게 프로그램을     
  만들어 갈 수 있다. 해서 상속을 사용하는 궁극적인 이유는 코드의 중복을    
  줄임과 동시에 다형적 기능을 이용하는 것이다.     
  
  하지만 위 두 가지 장점은 반대로 두 가지 단점도 가지고 있다.     
  첫 번째 단점은 단지 코드의 중복을 줄이기 위해 각 클래스들의    
  공통분모만을 뽑아 만든 일반화 된 부모 클래스의 인스턴스를 생성       
  했을 때이다. 이 경우 부모 클래스는 아무런 의미가 없다. 하지만    
  인스턴스가 생성되기 때문에 분명 처음 클래스 제작자의 의도와는    
  다르게 사용될 여지가 있고, 실수를 만들 수 있다.     
  
  두 번째 단점은 오버라이딩을 통해 구현하려고 하는 메서드를    
  부모클래스에 만들어 놨지만 오버라이딩 자체는 강제가 아니기     
  때문에 이를 빼먹을 수 있다는 것이다. 하지만 어떤 메서드가 실행될 지는      
  실행 시점에 결정되기 때문에 내가 오버라이딩 하지 않으면 부모 클래스의    
  메서드가 실행되게 된다. 그렇게 되면 실행시점에 내가 원하지 않는    
  결과를 맞이할 가능성이 있다. 즉 실수할 여지를 둔다는 것이다.          
  
  위 두 문제를 아래 소개할 추상 메서드와 추상 클래스를 이용해     
  해결할 수 있다.      
***
* 추상 메서드란 구현부가 없는 메서드를 말한다. 구현부란 `{}` 중괄호 내부를 말한다.      
  구현부가 없다면? 시그니처만 있는 메서드이다. 즉 `public int add(int a, int b);`     
  이렇게 접근제어자, 반환타입, 메서드명, 매개변수 타입, 그리고 세미콜론으로     
  끝나는 특징을 지닌다. 그냥 하나의 구문으로 만드는 것이다. 그리고 위 메서드에       
  `abstract` 키워드를 붙여줘 최종적으로 `abstract public int add(int a, int b);`        
  형태를 가지는 메서드가 추상 메서드이다. 구현부가 없는 것이 특징이다.      
  
  그리고 추상 메서드를 가지는 클래스는 미완성 메서드를 가졌기 때문에 무조건 추상클래스가     
  되어야 한다. 즉 컴파일러 단계에서 추상 클래스를 강제하는 것이다. 클래스 역시 `abstract`    
  키워드만 접근제어자 앞에 붙여주면 된다. 그렇게 되면 해당 클래스는 추상 클래스가 된다.     
  이렇게 추상메서드와 추상클래스의 모양에 대해 알아봤다. 그럼 이게 어떤 장점이 있으며,    
  위에서 봤던 단점을 어떻게 보완 한다는 것인가?          
  
  첫 번째 문제는 단지 기능적으로 이용하려던 부모클래스의 인스턴스가 생성되는 문제가 있었다.    
  그렇기 때문에 아무 의미 없는 인스턴스가 생성될 가능성이 열려 있었고, 이로 인해    
  의도치 않은 실수를 유발할 여지가 있었다. 하지만 추상클래스는 기본적으로 인스턴스의    
  생성이 불가능하다. 즉, 부모타입으로 참조변수의 타입될 수는 있지만 추상클래스 타입으로     
  실제 인스턴스를 생성하지 못한다는 것이다. 이는 어찌보면 당연하다. 추상적이라는 단어의    
  의미를 봐도 예상할 수 있고, 아직 완성되지 않은 클래스이기 때문에 인스턴스의 생성이    
  불가능 하다. 생성 됬을 때 추상메서드에 접근하면 어떻게 처리할 것인가? 컴파일러 입장에서는    
  답이 안나오는 경우이기 때문에 애초의 인스턴스 생성이 불가능하다. 그렇기 때문에 공통된    
  기능만을 가지는 부모클래스는 추상클래스로 만들어 인스턴스의 생성을 아예 막아 놓는다면     
  명확하게 의도를 전달하고, 실수를 방지할 수 있는 여지를 줄일 수 있을 것이다.      
  
  두 번째 문제는 추상메서드를 가지고 있는 추상클래스를 상속 받은 자식클래스들은    
  무조건 추상메서드를 오버라이딩 해 재정의 해야 한다. 즉 이 부분도 컴파일러가      
  강제할 수 있는 부분이기 때문에 오버라이딩을 빼먹는 실수를 없앨 수 있다.      
  만약 오버라이딩 하지 않는다면? 컴파일이 안되겠지 뭐...      
  이렇게 함으로써 추상클래스 타입으로 참조변수를 선언하고 자식타입으로 참조를 생성해     
  저장하게 됬을 때 추상메서드에 접근하면 당연히 자식클래스에 오버라이딩 된 메서드를     
  호출하게 되고 깔끔하게 다형적 기능을 이용할 수 있게 된다. 이렇게 됨으로써 실수할 수      
  있는 부분을 사전에 차단하고, 명확하게 의도를 전달하는 프로그래밍을 할 수 있게 된다.      
  
  이렇게 하나의 메서드로 서로 다른 행동을 지시할 수 있는 것은 다형성의 핵심이다.     
  이렇게 함으로써 각 객체에 맞게 고유한 행동을 할 수 있지만 하나의 타입으로       
  선언하고, 실행 시점에 어떤 객체의 메서드가 실행될 지 결정되는 늦은 바인딩을 이용하기에        
  유연하게 객체를 추가해 확장이 가능한 것이다. 그냥 해당 추상클래스만 상속 받은 뒤      
  추상메서드만 오버라이딩 하면 끝이기 때문이다. 이렇게 강력한 다형성을 이용해      
  유연성과 확장성을 가질 수 있게 됬다.     
***
이정도 정리하면 될 거 같다. 확실히 이해한 거 같다. 이 부분은.      
까먹기 전에 영상한 번 더 보면서 다지면 될 거 같다.    
