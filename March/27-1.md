# 객체지향 사실과 오해     
>구현하지 않고 머릿속으로만 구상한 설계는      
>코드로 구현하는 단계에서 대부분 변경된다.      
>설계 작업은 구현을 위한 수케치를 작성하는     
>단계지, 구현 그 자체일 수는 없다. 중요한 것은     
>설계가 아니라 코드다. 따라서 협력을 구상하는 단계에      
>너무 오랜 시간을 쏟지 말고 최대한 빨리 코드를 구현해서      
>설계에 이상이 없는지, 설계가 구현 가능한지를 판단해야 한다.      
>코드를 통한 피드백 없이는 깔끔한 설계를 얻을 수 없다.     
>             
>222p         

* 설계는 설계고, 구현은 구현이다.    
  좋은 설계는 변경이 없는 완벽한   
  설계가 아니라 변경을 수용하면서     
  방향을 잡아줄 수 있는 설계이다.        
  
* 빠르게 설계를 해 틀을 잡고,     
  방향을 잡은 다음 구현을 통해    
  방향을 확인하면서 설계를 다듬어    
  가야한다.        
  
* 설계는 방향이지, 정답이 아니다.    
  코드를 통한 피드백을 받으면서    
  당연히 변경되어야 하는 대상이다.       
  
* 더 좋은 방향이 구현중에 나올 수 있고,      
  설계대로 구현되지 않기 때문이다.      
  
* 먼저 메시지를 설계하고, 이 메시지를    
  어떤 객체가 수신할 것인지 정하라.   
  그리고 기능을 어떻게 객체의 협력으로    
  구현할 것인지, 협력관계를 설계하라.    
  그 후 객체가 요청에 응답하기 위해    
  필요한 로직을 구현하고, 그 과정에서      '
  객체가 가져야 할 상태를 선택하는 것이다.      
  
* 일단 최대한 빠르게 구현을 하되,  
  아무것도 없이 하는 것이 아닌    
  최소한의 설계를 두고 구현하는 것이다.     
  
* 이 기준을 삼는다면 설계에 너무 많을    
  시간을 쏟지 않을 수 있을듯 하다.    
  
* 어쨋든 설계는 설계일 뿐이다.       

>상공에서 바라본 소프트웨어의 전체적인   
>구조를 표현하기 위해 관련된 클래스의 집합을    
>하나의 논리적인 단위로 묶는 구성요소를    
>패키지 또는 모듈이라 한다.     
>     
>249p       

* 패키지를 이용하면 시스템의 전제적인      
  구조를 이해하기 위해 한 번에 고려해야 하는    
  요소의 수를 줄일 수 있다.     
  
* 클래스의 집합을 캡슐화 함으로써 전체적인    
  복잡도를 관리할 수 있다. 기준은 함께 협력하는     
  응집도 높은 클래스 집합을 하나의 패키지 내부로    
  묶는 것이다.      
  
* 어쨋든 협력을 설계하다보면 최소한의 의존성은     
  생기기 마련이다. 물론 이 의존성을 최소한으로     
  관리하는 것이 중요하겠지만 아예 없을 수 없다.    
  메시지를 전달하려면 의존성이 필요하기 때문이다.     
  
* 이렇게 협력관계에 있는 객체들을 묶으면   
  전체적인 객체들의 협력 관계와 추상화를       
  파악하고 관리하는데 도움이 된다.      
  
* 클래스가 관련있는 책임(행동)과 상태를    
  캡슐화 함으로써 응집도를 가지고   
  객체 그 자체만으도 의도를 전달하듯이,    
  의존성을 가지는 객체들을 서로 모으고,      
  협력관계에 있는 클래스들을 패키징 함으로써    
  복잡성을 줄이고, 전체적인 그림을 파악하는데    
  효과를 볼 수 있다.     
  
