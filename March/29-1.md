# 오늘 공부한 내용     
* jsp를 이용할 땐 너무 많은 역할을 jsp가 담당했다.    

* 비즈니스 로직 뿐 아니라 뷰를 그리는 로직까지 jsp에서   
  담당하다 보니 가독성, 유지보수성이 현저히 떨어지는     
  단점이 있다.    
  
* 변경의 라이프 사이클이 다를 때 분리를 고려해야한다.   
  즉, 비즈니스로직과 html 뷰 로직의 변경이 항상 같이    
  일어나는 것이 아니다.     
  
* 그래서 이렇게 변경이 다를 땐 분리하는 것을 고려하면     
  좋다. 서로의 변경이 영향을 끼치지 않으니까.    
  
* 이를 해결하기 위해 나온 것이 mvc 모델이다.    

* 현재는 view - controller - service로 이어지는     
  mvc2 방식을 사용해 개발한다.    
  

* 또한 view 와 controller의 분리를 위해 model이라는     
  데이터 운반 객체를 둬 로직의 분리를 이뤄냈다.    
  
* 어쨋든 jsp 파일에서 필요한 것은 데이터였다.    
  이 데이터만 전달할 수 있다면 로직의 분리가    
  가능한 것이고, controller에서 model에 데이터를 담아      
  view, jsp 파일에 보내는 것이다.   
  
* 이렇게 되면 jsp는 html을 동적으로 랜더링 하는데만    
  집중할 수 있고, 그 외 비즈니스 로직은 servlet에서     
  집중할 수 있는 것이다.      
  
* 상대경로란 현재 디렉토리 경로 뒤에만 바꾸는 것을 말한다.            
  즉 현재 디렉토리 경로를 유지하면서, 맨 뒤에만 바뀐다               
  해서 html form action을 상대경로로 지정해주려면              
  그냥 경로명만 지정해주면 된다.                      
  
* 즉, 현재 경로를 전부 유지하기 때문에 /도 붙일 필요가 없다.              
  그냥 경로 이름만 지정해 주면 찾아 들어간다.                    
  html 파일을 지정하는 것이 아니다.                  
    
* 경로를 입력해줘야 controller에 경로를 지정해준 메서드를         
  찾아들어간다. 상대경로를 지정해줘야 가능하다.         
  
* 절대경로는 최상위 폴더부터 전부 적어주는 것을 말한다.            

* 이런 servlet, jsp 구조 역시 한계가 있다.      
  1. 코드의 중복, jsp로 이동시켜주는 forword() 메서드,        
     viewPath 같은 경로를 지정해주는 변수가 중복된다.        
     중복은 결국 유지보수를 어렵게 하는 원인이 된다.        
     util class를 만들어도 어쨋든 호출의 중복이 생긴다.    

  2. 공통된 로직을 처리하기 힘들다.    
     분명 요청이 들어왔을 때 전처리 할 수 있는      
     부분들이 있는데 이런 처리가 힘들다.     
     
  3. 사용되지 않는 response 객체가 계속 생성된다.   
     jsp에서 요청을 처리하게 되면서 response를 직접    
     사용하는 빈도가 줄었음에도, 여전히 response 객체를   
     생성해주고 있다.     
     
* 공통처리가 힘든 이유는 모든 요청이 각각 controller로 바로     
  들어오기 때문에 각각 공통 처리를 해줘야 했고, 필연적으로   
  코드의 중복이 생겼기 때문이다.     

* 해결책은 서블릿 객체가 생성되기전에 수문장 역할을 하는 객체를      
  만들어 해당 객체를 통해 전처리를 하고, 알맞는 컨트롤러를    
  호출할 수 있게 하는 것이다.    
  
* 이렇게 되면 공통 로직을 앞에서 처리할 수 있고,    
  앞에 객체를 통해서만 서블릿이 호출되게 된다.     
  필요한 전처리 후 서블릿이 호출되는 구조이다.    
  
* 또한 요청에서 바로 controller로 들어오는 것이 아닌    
  앞에 수문장 객체를 통해 controller로 들어오게 된다.    
  해당 요청에 따라 어떤 controller 객체를 사용할 것인지     
  결정하는 것 역시 앞에서 결정하게 된다.    
  
* 그리고 공통처리 역시 앞에서 진행하고, controller를 호출해   
  controller에서는 데이터만 받아서 비즈니스 로직을 호출,   
  실행하고 결과를 반환하면 된다.    
  
* 프론트 컨트롤러 패턴은 각 컨트롤러 앞에서 공통된 로직을   
  처리하고 controller를 호출하는 컨트롤러 패턴이다.    
  
* 이렇게 되면 앞에서 공통 로직을 처리하기 때문에   
  각 컨트롤러에서 중복된 코드 없이, 비즈니스 로직만을    
  수행하고, 해당 값을 반환, 프론트 컨트롤러가     
  최종적으로 응답을 수행하기 된다.    
  
* 즉, 프론트컨트롤러만 서블릿이면 된다. 이 전에는    
  모든 컨트롤러가 서블릿을 상속 받아 각각 서블릿   
  객체로써 관리되었는데, 이제는 프론트 컨트롤러     
  하나만 서블릿을 상속 받고, 일반 컨트롤러들을   
  호출하는 식으로 진행이 된다.    
  
* 이렇게 되면 모든 컨트롤러가 서블릿이 필요가 없다.    
  프론트 컨트롤러 하나만 서블릿이면 된다.     
  
* 팁 : 한 번에 하나씩 개선해야 한다. 어쨋든 전체적인    
       리팩토링을 진행해야 할 때, 한 번에 모든것을     
       바꾸려고 한다면 기존의 것들에 어떤 문제가   
       생길 지 알 수가 없다.   
       항상 점진적으로, 같은 레벨에 있는 것들을 먼저   
       변경을 하고, 세부적인 디테일로 내려가라.   
       즉, 구조를 변경하면, 구조만 변경하고,잘 돌아가는지   
       확인한 뒤, 디테일을 변경해야 한다.    
       항상 한 번에 한 가지씩만 하자.      
       
* 팁 : 실제 개발 시 절대경로를 사용한다. 즉, 디폴트로 지정된    
       상위 폴더를 제외한 나머지 모든 경로를 지정해 주는 것을   
       절대경로라 한다.      
       상대경로를 사용할 땐, 경로가 위치가 같고, 해당 뷰를 재활용할 때    
       사용할 수 있다.             
       
* 프론트 컨트롤러는 컨트롤러 인터페이스와 구현체들의 상위에 위치한다.      
  해서 자신의 하위에 있는 경로로 들어오면 일단 프론트 컨트롤러가 호출될 수    
  있도록 경로를 지정한다. 그럼 어떤 경로든, 프론트 컨트롤러로 요청이 들어오고,    
  상세한 경로, `request.getResourceUrl()`을 통해 상세 경로를 반환받고,    
  이를 통해 관련 컨트롤러 객체를 생성해 사용하는 것이다.     
       
* 현재 프론트 컨트롤러를 개발했고, 이 프론트 컨트롤러만 서블릿으로 구현했다.   
  그리고 맵에 키를 경로를 지정하고, 해당 경로로 들어왔을 때 반환하는    
  컨트롤러 객체를(컨트롤러를 구현한 구현채) 값으로 가진다.     
   
* 이렇게 되면 일단 모든 요청이 프론트 컨트롤러에 모이게 되고,               
  추후 요청에 따라 알맞는 컨트롤러 구현체를 이용해 해당 요청에 맞는            
  응답을 처리하게 된다. 구현체를 이용해서.                               
  
* 구현체 컨트롤러에서 공통적으로 사용하는 메서드는 인터페이스에서    
  추상메서드로 정의 되어 있다.   
  그리고, 이를 구현한(implement) 클래스들에서 메서드의 시그니처를    
  재정의 하고, 상세한 구현을 만들어 각자 수행할 작업을 정의한다.    
  
* 이렇게 프론트 컨트롤러는 맵핑 정보를 통해 컨트롤러를 찾고,   
  찾은 컨트롤러를 호출해 요청에 따른 비즈니스 로직을 수행하게 된다.       
