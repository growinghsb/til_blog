![prg 리다이렉션](https://user-images.githubusercontent.com/60066223/111115400-e6043480-85a7-11eb-98cd-a67ec9c15625.PNG)
# 네트워크    
* IP프로토콜이란?    
  * IP프로토콜은 각 pc나 모바일에 고유로 주어진 IP 주소를 기반으로 통신하는 통신규약이다.    
  * 각 디바이스간 통신은 IP프로토콜을 통해 진행된다. 이 때 보내는 디바이스와 받는 디바이스의 주소가   
  IP주소가 된다. 그리고 보낼 데이터를 패킷으로 만들어 보내는 디바이스, 받는 디바이스의 IP 주소를 입력하고   
  패킷을 인터넷을 통해 전송하게 된다.    
  * 즉 IP프로토콜을 이용하기 위해선 IP주소가 필요한 것이다. 그리고 보낼 데이터 단위를 패킷으로 만들어 보낸다.   
* IP프로토콜의 한계    
  1. 비연결성 : 내가 보낸 패킷을 받는 곳의 디바이스의 상태를 신경쓰지 않는다. 즉 패킷을 받을 수 없는 상태임에도    
  일단 보낸다. 이렇게 서로의 연결이 확인되지 않는 상태임에도 일단 패킷을 보낸다.     
  
  2. 패킷이 유실될 가능성이 있다. 결국 내가 보낸 패킷은 인터넷망을 통해 여러 노드를 거치면서 상대방에게 도착하게 된다.   
  이 때 노드는 서버가 되는데, 이 서버가 만약 죽는다면? 어떠한 이유로 패킷을 전달할 수 없는 상태가 되면   
  이 패킷은 유실되는 것이다.   
  
  3. 패킷은 보내는 데이터의 크기에 따라 결정된다. 즉 내가 보내는 데이터의 크기가 크면 이 데이터를 여러개의 패킷으로 나눠    
  보내게 되는 것이다. 하지만 인터넷 망을 통해 패킷이 전달되는 과정에서 당연히 순서대로 패킷이 전달되지 않는다.    
  같은 데이터 패킷이라도 서로 다른 노드를 통해 전달 될 수 있으며 이 과정에서 패킷의 순서가 뒤바껴 전달되기도 한다.    
  
  4. 같은 IP주소를 이용하는 여러개의 프로그램이 있다면, 각각의 프로그램에서 전송하는 데이터 패킷을 어떻게 구분할 것인가?   
  게임을 하면서 음악을 들을 때, 게임 데이터도 실시간으로 내 pc로 전송 되어야 하고, 음악 데이터도 실시간으로 전송되어야 한다.    
  같은 IP주소에서 서로 다른 데이터 패킷을 구분할 수 없다.     
***
* TCP를 이용한 IP한계 극복   
  * 네트워크 통신 4계층이란?      
    맨 위에 애플리케이션 계층이 있다. 대표적으로 Http가 있고, 데이터가 발생된다.     
    그 밑에 TCP 계층이 있다. 위 애플리케이션 계층에서 발생한 데이터를 TCP 정보로 한 번 감싼다.       
    그 밑에는 IP계층이 있다. IP계층의 한계를 극복하기 위해 TCP계층을 위에 얹은거라 볼 수 있다.       
    그 밑에는 물리적인 네트워크 인터페이스가 있다. 위에서 박싱 된 IP패킷을 물리적인 네트워크를 통해 전송한다.       
    
  * 이렇게 TCP계층을 한 번 감싸게 되면 3가지 이점을 얻을 수 있다.              
    1. 연결을 보장한다(논리적으로) : 3 way handshake를 통해 내가 전송할 데이터를 받을 디바이스와의 연결을     
       보장한다. 보내는 쪽에서 처음 syn을 보내고 받는 쪽에서 ack, syn 을 보낸다. 그럼 보내는 쪽에서 ack를 보내면서     
       데이터도 같이 보낸다. 이렇게 서로 연결됬음을 보장한다. 하지만 두 디바이스 사이에 있는 노드들은 연결됬는지 모른다.   
       즉 직접적으로 데이터를 주고 받는 디바이스간에 연결이 됬구나 하는 것이다.    
    
    2. 패킷의 순서를 보장한다. : 처음 IP프로토콜의 한계는 패킷의 순서를 보장하지 않는다는 것이었다. 즉 내가 보낸 데이터가    
       내가 의도한대로 도착하지 않을 가능성이 있었다. 하지만 TCP프로토콜은 이를 보장한다. 만약 받는 쪽에서 패킷의 순서가    
       뒤바꼈다는걸 알게 되면 해당 순서부터 다시 요청을 하게 된다.    
    
    3. 패킷의 손실을 알 수 있다. : 여러 이유로 내가 보낸 패킷이 손실 될 수 있다고 했다. TCP프로토콜을 사용하면    
       이러한 패킷의 손실을 알 수 있다.    

* 이러한 이유로 현재는 TCP/IP 프로토콜이 전세계적으로 사용되고 있다. 신뢰 기반 프로토콜이라고도 한다.     
***
* Port란?
  * 하나의 클라이언트 디바이스가 여러개의 서버 pc와 작업을 하고 있을 때 각각의 서버가 보내는 데이터 패킷을    
  구분하기 위해 사용하는 개념. 즉 각각의 패킷은 서로 다른 Port로 전송되기 때문에 하나의 클라이언트에서    
  구분할 수 있게 되는 것이다.    
  
  * 이 Port 번호는 보내는 쪽과 받는 쪽 둘다 패킷에 기록되는데 이 역시 TCP 계층에서 박싱할 때 Port번호를 같이 박싱한다.    
  그렇기에 IP 프로토콜의 한계인 패킷을 구분하는 문제를 Port로써 해결하는 것이다.    
  
  * 이 Port는 이런 비유로 정리할 수 있다. IP주소는 하나의 아파트 동이고, Port는 각각의 집을 나타낸다.    
  택배를 보낼때도 주소에 적어 보내듯이 똑같다. 패킷은 하나의 택배이고, 이 택배를 보낼 때 당연히 택배에    
  주소를 기입해서 보내는데 이 주소는 IP와 Port번호가 되는 것이다. 받는쪽, 보내는 쪽 둘 다 보낸다.    
  
  * 해서 TCP/IP라고 하며 패킷 역시 TCP/IP 패킷이라 한다.    
***
* DNS란?   
  * IP주소는 인간이 기억하기에는 너무 어렵고 번거롭다. 또한 바뀔 가능성이 있다.     
  해서 이런 IP를 인간의 언어로 바꿔주는 서비스이다.      
  영어로 되어 있으며, IP주소와 매칭된다.     
  naver.com, google.com 등이 Domain 주소라고 하며 각각 고유의 IP와 매핑되어 있다.
***
* URI란?    
  * URL 과 URN을 포괄하는 개념으로 Uniform Resource Identity의 약자이다. 자원을 식별할 수 있는 정보라는 의미.
  * URL은 Location으로 리소스가 있는 위치, 주소를 나타낸다.   
  * URN은 거의 쓰이지 않는다. 해서 URI와 URL은 거의 비슷한 의미로 쓰인다.    
  * URL 주소란 https://github.com/growinghsb/til_blog/new/main/March 이런 주소를 말한다.
  * https는 통신 프로토콜로 schme라고 하며 https포트 번호는 443, http는 80 port이다.      
  * github.com의 위치는 도메인 주소나 IP주소가 들어간다. 호스트명이라 한다.    
  * 그 뒤에는 port 번호가 들어가는데 생략 가능하다.     
  * 그 뒤에는 path가 들어가는데 리소스 경로이다. 계층적 구조로 되어있다.    
    /growinghsb/til_blog/new/main/March 이 부분이다. 계층적 구조로 되어 있다.
  * 그 뒤에는 query parameter가 들어간다. key - value 형태로 되어 있다. ?로 시작 &으로 추가 가능.   
    문자 형태로 전송된다. 기본적으로 문자로 넘어간다.    
***
* 웹 브라우저 전송 흐름
  * 요청흐름 : 애플리케이션 계층에서 http 요청 메세지 생성 -> socket 라이브러리를 통해 TCP/IP 계층으로 전송    
  -> IP번호와 Port번호를 박싱해서 기입 -> 해당 서버로 전송     
  
  * 응답흐름 : 똑같이 응답 메세지 작성, 이 때 Http Body에 요청에 따른 응답 데이터 기입 -> TCP/IP를 계층에서    
  박싱 후 전송.     
  
  * 위와 같은 흐름으로 데이터 전송이 된다. 데이터의 형태는 http 문서 뿐만 아니라 영상, 사진 등등 모든게 될 수 있다.    
  ***
  # Http
  * Http = > Hyper text transfer protocol의 약자로 http문서를 주고 받기 위해 만들어졌다.    
  하지만 지금은 http 문서 이외에 모든 것들을 http 프로토콜을 이용해 전송한다.    
  
  * http1, 2 까지는 TCP프로토콜을 기반으로 동작하고, http3는 UDP프로토콜을 기반으로 동작한다.    
  
  * http는 서버 클라이언트 구조로 동작하며, 요청과 응답 모두 http 메세지, 헤더, 바디에 데이터와 정보를 담아 전송한다.     

  * 지금은 바야흐로 Http의 시대이다. 모든 것을 Http에 실어서 보낸다.
  
  * Http의 특징     
    * 클라이언트 서버 구조 : Request, Response 구조로 통신한다. 이로써 클라이언트와 서버의 분리가 가능해졌다.    
      서버에 관련된 것들은 서버로 다 몰아 넣고, 클라이언트에서는 사용자를 위한 UI에만 짒중할 수 있게 되었다.    
      그렇게 되면서 독립적으로 발전이 가능해졌다. Http 프로토콜은 요청과 응답 구조로 서버와 클라이언트를 나눌 수 있다.      
      
     * 무상태(stateless) 프로토콜을 지향 : 무상태 프로토콜이란 서버가 클라이언트의 요청 상태를 저장하지 않는 것을 말한다.        
       저장하지 않으면 좋은 이유가 요청을 어떤 서버든 응답할 수 있다는 것이다. 클라이언트가 요청에 필요한 정보를 전부 담아        
       보내기 때문에 서버는 그에 따른 응답만 하면 되고, 이 응답 과정에서 어떤 서버가 응답을 하던 상관이 없는 것이다.             
       이는 서버의 scale out 즉 확장성을 가질 수 있고, 트래픽에 따라 유연한 대처가 가능하게 된다.        
       대부분의 설계는 기본적으로는 무상태로 하되, 로그인 같이 클라이언트의 상태를 저장해야 하는 상황에서만 제한적으로          
       상태를 저장하는 방식(stateful)으로 설계해야 한다.        
        
     * 비연결성 : 기본적으로 http프로토콜은 연결을 지속하지 않는다. 연결을 지속한다는 것은 계속해서 서버의 자원을     
       소모한다는 의미이기 때문이다.    
       해서 현재는 http파일 및 관련된 파일들을 다 받아 올 때 까지 연결을 유지하고, 이 이후 연결을 끝난 방식을 사용한다.     
       그리고 항상 http프로토콜을 이용한 설계를 할 때는 어떻게든 무상태 프로토콜로 설계해야 한다.       
       
     * Http 메세지 : 시작라인, 헤더, 바디로 이루어져 있다. 이 메세지를에 정보를 담아 TCP/IP 박싱을 통해 데이터를 전송하는 것이다.    
       요청메세지와 응답메세지에 들어가는 내용이 조금씩 다르다.
       ![http 메세지](https://user-images.githubusercontent.com/60066223/111098166-408c9900-8586-11eb-9360-69c76d7d57ac.PNG)
       ![http메세지 구조](https://user-images.githubusercontent.com/60066223/111098170-42565c80-8586-11eb-8a0f-04dac3ca3552.PNG)   
       위와 같은 구조로 되어 있다. 
***
* Http 메서드란 자원과 행위를 구분 지을 때 해결되지 않는 행위에 대한 구분을 http메서드를 통해 할 수 있게 해준다.    
  API를 설계할 땐 URL에 자원과 행위를 구분짓는 것이 중요하다. 즉 /member/delete 등과 같이 URL에 행위에 대한 정보가    
  들어가지 않도록 설계해야 한다. 이렇게 행위에 대한 정보를 다 빼면 URL을 설계하기가 번거로워 진다.    
  /member 이후에 뭐가 수정, 삭제, 저장일 때 어떻게 나눠야 하지? 라는 고민이 생긴다.    
  이 고민을 해결해 주는 것이 Http메서드이다.
  
* Http메서드 GET, POST   
  GET메서드는 조회를 요청할 때 사용한다. qurey string 을 통해 서버에 자원을 요청하고, 서버는 해당 query string에 담겨온    
  데이터를 통해 자원을 조회하고, 그 자원을 담아 요청에 대한 응답을 처리한다. GET메서드에도 body에 데이터를 담아 요청할 수 있지만    
  이를 지원하지 않는 서버가 많아 잘 사용되지 않는다. GET은 조회를 위해 사용된다.   
  
  POST 메서드는 클라이언트가 데이터를 담아 서버에 요청하는데 주로 사용된다. 회원가입, 게시글 등록, 댓글 등록 등    
  http body에 데이터를 담아 서버에 보내고, 서버는 요청에 대한 알맞은 처리를 담당하게 된다.    
  서버는 POST 요청이 오면 데이터에 맞는 알맞는 처리를 할 수 있도록 리소스마다 따로 지정되어야 한다.
  그리고 리소스 만으로는 설계하기가 번거롭다. 해서 컨트롤 URI를 만들어 행위를 URL에 넣는 것이다.   
  조회에도 POST를 사용할 수 있다. POST는 다된다. 하지만 조회에 GET이 있기 때문에 최대한 나눠 사용하는 것이    
  중요하며 상황과 맥락에 맞게 선택해 사용하는 것이 중요하다.    
  
* PUT, PATCH, DELETE   
  PUT은 리소스를 완전히 대체한다. 즉 파일을 저장할 때를 생각하면 된다. 이름이 같을 때 저장하면 그냥 덮어버린다. 내용에 상관없이.       
  클라이언트에서 PUT 요청을 하면 기존 리소스를 그냥 덮어 버린다. 수정이 아니라 그냥 바꿔치기 해버린다. 기존 리소스는 사라진다.       
   
  PATCH는 부분적으로 리소스를 변경 요청하는데 사용한다. 즉 수정할 때 사용한다.         
  
  DELETE는 삭제를 요청할 때 사용한다.      
  
  애매할 땐 POST를 사용한다.     
  
* HTTP 메서드의 속성   
  ![HTTP 특징표](https://user-images.githubusercontent.com/60066223/111101251-de836200-858c-11eb-9fc8-26d28f327e51.PNG)            
  
  안전 : 변하지 않는 것을 안전이라 한다. 즉 요청을 했을 때 대상 리소스가 변하는지, 변하지 않는지에 기준을 둔다.            
         그리고 안전하다의 기준은 해당 요청에 한해서만 안전이라는 기준을 매긴다. 즉 요청을 했을 때 데이터가 변하는지           
         변하지 않는지만 본다는 것이다.          
         
  멱등 :  몇 번을 호출하든 결과 값이 같은 것을 멱등하다 라고 말한다. 처음 요청한 것과 그 뒤에 N번 요청한 결과가 같으면                         
          멱등하다고 한다.           
          POST는 멱등하지 않다. GET, PUT, DELETE 는 멱등하다.              
          멱등이 필요한 이유는 요청에 대한 응답이 없을 때 재시도 할 수 있는가?에 대한 기준을 멱등으로 기준을 삼을 수 있다.              
          요청에 대한 응답이 없을 때 재요청 할 수 있는 요청 메서드는 멱등한 메서드들만 재요청이 가능하다. 어짜피 결과는               
          변하지 않기 때문이다.            
          멱등은 외부 요인으로 동일한 리소스가 변경 되는 것 까지는 포함하지 않는다. 이 경우 멱등하지 않다라고 보고 다른 처리를 해야한다.                   
          
  캐시가능 : 응답 결과를 캐시해서 사용해도 되는가? 실제로는 GET과 HEAD만 캐시로 사용한다. POST와 PUT의 경우 응답 데이터까지                      
             캐시 키로 잡아야 하기 때문에 사용하지 않는다.                 
             GET 요청 시 URL을 키로 잡고 응답 데이터를 캐시해 놨다가 동일 요청 시 서버에서 같은 데이터를 보내는 것이 아니라                 
             URL을 비교, 캐시해 두었던 데이터를 그대로 사용하게 된다. 해서 현재는 GET정도만 캐시해서 사용한다.                    
             즉 자주 요청이 되는 데이터는 캐시에 저장해 두고, 필요할 때 마다 캐시 저장소에서 데이터를 불러오는 것이다.                           
***
* Http API 데이터 전송 시     
  1. 서버 to 서버 통신에 이용           
  2. 앱 클라이언트와 통신할 때, 아이폰, 안드로이드          
  3. 웹 클라이언트, ajax통신을 할 때         
     POST, PUT, PATCH등의 메서드 사용 가능 메세지 body에 데이터 넣어서 요청 가능              
     GET으로 조회 요청 가능, 쿼리 파라메터를 전송해서 요청          
     JSON 형태의 데이터 전송 방식 사용      
***
* Http API 설계 시     
  * 리소스(자원)으로만 구분을 지어야 한다. 행위에 대한 구분은 http메서드로 구분한다.    
  * PATCH는 부분 수정, PUT은 전체를 그냥 덮어버린다. 대체한다. 애매할 땐 POST.    
  * PUT을 사용할 땐 클라이언트가 리소스 경로를 알고 있어야 한다.    
  * POST의 경우 리소스 경로만 서버에 보낸다. 즉 요청만 하는 것이다. 하지만 PUT 기반으로 등록할 땐      
    클라이언트가 자원의 경로를 전부 알고, 관리한다(store)    
  
  * http api 설계 시 post(collection) 방식과 put(store) 방식이 있다.      
    거의 post만 사용한다.      
  
  * 컨트롤URI는 최대한 리소스와 http메서드로 나눠서 구분하고, 애매한 경우에만 동사를 사용하는 컨트롤URI를 사용하자.      
    
* 실제로 서버에서 각 메서드마다 맵핑할 수 있는 어노테이션을 지원한다.       
  해서 API 통신을 할 땐 그 상황에 알맞는 http 메서드를 사용하고    
  메서드로 딱 떨어지지 않을 땐 컨트롤URI를 사용하라. POST에 그냥 동사형 경로를 지정하는 것.
***
* http 상태코드    
 * 2xx : 성공
 * 3xx : 리다이랙션
![prg 리다이렉션](https://user-images.githubusercontent.com/60066223/111115455-fae0c800-85a7-11eb-86af-b0d93d9581b1.PNG)   
* prg란 post/redircetion/get 의 약자이며 일시적 리다이렉션을 말한다.    
* 마지막 요청에서 새로고침을 하면 이전 요청이 새로고침이 된다.     
* 만약 마지막 요청이 주문을 하는 요청이었다면 새로고침 시 재주문이 들어갈 것이다.    
  이 상황을 방지하기 위해 post 후 get으로 바로 redirection을 요청하는 것이다.   
  그럼 다음 마지막 요청 자체가 get 요청일 것이며, 새로고침을 해도 재주문 되지 않을 것이다.     
  회원가입 후 로그인 화면으로 바로 redirection 하면 새로고침을 해도 로그인 화면이 다시 뜰 것이다.   
  만약 prg 처리를 하지 않으면 새로고침 시 가입된 회원을 한 번 더 가입을 요청하는 상황이 될 수 있다.

* 4xx : 클라이언트 오류, 클라이언트 잘못, 요청 잘못. 이 오류의 경우 요청 내용을 재검토해서 다시 보내야 한다.     
  계속 오류가 나기 때문에 클라이언트 측에서 명확하게 알 수 있도록 오류를 보내 주어야 한다.     
  
* 5xx : 서버 오류, 서버에 문제가 있기 때문에 서버가 복구되면 같은 요청을 보내도 응답이 올 수 있다.    

* 이 차이를 알아야한다. 클라이언트 오류는 요청이 잘못됬기 때문에 몇 번을 재시도 해도 응답이 불가하다.    
  하지만 서버 내부에 문제가 있기 때문에 요청은 문제가 없다. 그래서 재시도 시 응답을 받을 가능성이 있다.
  
* API 개발 시 5xx 에러는 정말 서버에 문제가 생겼을 때만 5xx에러로 응답해야 한다.      
  비즈니스 로직에서의 예외를 5xx에러로 발생시키면 안된다.        
  이 땐 확실히 사용자가 인지할 수 있는 예외처리를 해야 한다.     
