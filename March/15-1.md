# 객체지향
* 탄생 배경    
  * 유지보수 하는 비용이 너무 크다. 변화에 유연하게 대처할 수 없다. (기존의 절차지향)       
  
  * 객체지향은 위같은 문제를 해결하기 위해 탄생했다.             
    객체지향은 어떻게 비용을 낮추나??          
    캡슐화 + 다형성(추상화) 이 두가지가 핵심이다.       
 ***   
* 객체    
  * 객체의 핵심은 기능 제공이다. 객체는 가지고 있는 필드(상태)로 정의되지 않는다.              
    어떤 기능을 하는지에 따라 정의된다. 객체는 기능에 따라 구분 되어져야 한다.       
    
  * 객체의 기능은 곧 메서드이다. 즉 메서드를 이용해 기능을 정의한다.     
                   
  * 객체가 가진 기능을 사용하는 것이 곧 메서드를 호출하는 것이다.         
***
* 캡슐화   
  * 캡슐화만 잘해도 좋은 코드를 작성할 가능성이 높아진다.       
         
  * 캡슐화는 객체가 기능을 어떻게 구현했는지,              
    어떤 데이터가 어떻게 값이 변하는지를 외부로부터 감춘다.          
   
  * 캡슐화는 기능을 제공하고 구현 상세를 감추게 된다.      
    이렇게 되면 해당 기능에 대한 요구사항이 변경되도,        
    일일히 코드를 쫒아 다니면서 기능을 변경하지 않아도 된다.         
    그냥 추가 하거나 삭제하면 해당 기능을 사용한 모든 코드에 반영이 된다.            
    
  * 유지보수성이 올라간다. 기능 = 메서드         
  
  * 외부에 노출 된 기능의 변경 없이 내부 기능만 변경을 하면 된다.         
  
  * 캡슐화를 사용하면 변경에 따른 영향을 최소화 할 수 있다.           
 
  * 캡슐화를 하다 보면 기능에 대한 이해를 높힐 수 있다.    
    어떤 기능을 하는지 명확하게 구체화 해야 하기 때문.       
    항상 메서드의 설계는 해당 객체가 어떤 역할과 책임을 맡고 있고,       
    어떤 기능을 함으로써 무슨 데이터를 어떻게 바꿀 것인지 생각하라.       
    
  * Tell, Don t Ask 하라. 즉 데이터를 달라하지 말고 해달라고 하라. 작업을 요청하라.               
  
  * Demeter s Law 도트 연산자는 하나만 사용하라.    
    객체 자신의 메서드만 호출해 사용하라.            
    그렇기에 관련된 기능을 묶어 캡슐화 해야 한다.     
    
  * 캡슐화를 시도하는 기준     
    * 외부에서 객체의 데이터를 달라고 요청할 때     
    * 외부에서 객체의 데이터에 어떤식으로든 접근해     
      데이터를 변경 할 때.     
   
  * 데이터의 주체는 객체이다.     
    그리고 객체의 상태(데이터)를 변경하는 것 역시
    객체 내부의 기능, 즉 메서드이다.    
       
  * 항상 객체의 상태를 변경하는 것은 기능이며,        
    이 기능은 객체 내부에서 캡슐화의 형태로 존재한다.         
    그리고 외부에서는 기능을 이용한 데이터의 변경이         
    어떤식으로 이루어 지는지 알 수 없다. 캡슐화로 인해.     
    
  * 다시 한 번 : 객체의 상태를 변경하는 것은 객체의 행위이다.     
    그리고 외부로부터 어떤식으로 데이터가 변경되는지 감추는 것이    
    캡슐화이다. 만약 외부에서 객체의 데이터를 변경하고 있다면     
    이는 리팩토링의 대상임을 명심하자.     
 
  * 데이터의 변경은 데이터를 가진 주체의 기능으로써 행해져야 한다.   
### 객체의 상태를 변경하는 것은 곧 객체 자신이어야 한다. 
