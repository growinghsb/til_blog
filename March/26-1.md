# 객체지향 사실과 오해 정리     
>책임이 자율적일수로 적절하게 추상화되며,    
>응집도가 높아지고 결합도가 낮아지며    
>캡슐화가 증진되고, 인터페이스와 구현이     
>명확히 분리되며      
>설계의 유연성과 재사용성이 향상된다.   
>     
>176p     

* 책임이란 객체가 응답하는 방식을 의미한다.     
  어찌됬든 요청을 받은 객체는 자신만의 방식으로     
  응답할 자유가 있고 이 자유가 보장 됬을 때,      
  위의 것들을 얻을 수 있다.     
  하나씩 설명해 보겠다.     
  
* 추상화 된다라는 것은 구체화에 의존할     
  필요가 없어진다는 것이다.     
  구체적인 것들을 한데 묶는 추상적인 개념을 만들어     
  복잡성을 관리하게 되는데 기본적으로 추상화를    
  사용하게 되면, 구체적인 것에 직접 의존하지     
  않아도 되기 때문에 결합도가 낮아진다.    
  또한 유연한 설계가 가능하다. 어찌됬든   
  추상화에 의존 하게 되면 구체적인 것을 사용해도    
  궂이 알 필요가 없기 때문이다.         
  
* 응집도가 높아진다의 의미는 객체 내부에    
  행동과 상태가 서로 긴밀하게 관계를 맺고     
  있음을 의미하며, 요청받은 응답을    
  처리하는데 있어 부족함이 없다는 의미이다.   
  응집도가 높은 객체를 설계하게 되면     
  객체의 자율성이 올라가고, 다른 객체와의   
  결합도가 낮아지며, 수정과 확장에 유연한    
  설계를 가지게 된다.      
  
* 결합도가 낮아진다는 것은 요청 받은 응답을    
  처리하는데 있어서 다른 객체와의 최소한의    
  의존성을 가지고 협력을 진행할 수 있다는 의미이다.     
  결합도가 낮아지면 수정과 확장에 유리하다.    
  이유는 객체의 변경이 객체 내부에서 끝날    
  가능성이 높고, 이로인해 외부에는 변경이    
  전달되지 않는 것이다.   
  이렇게 되면 사이드이팩트가 관리 가능한     
  수준으로 낮아지게 된다.   
  
* 캡슐화가 증진되면 결국 응집도가 높아지고,    
  결합도가 낮아지는 효과를 얻게 된다.     
  캡슐화란 객체의 역할을 잘 나타내는    
  행동들과, 그에 의존하는 상태들이     
  얼마나 잘 응집해 있는지 나타낸다.    
  그리고 내부에 감춰야 할 것(구현),      
  외부에 노출시키는 공용 인터페이스가      
  명확하게 분리되게 된다.    
  
* 또한 캡슐화가 잘 되어 있는 객체는   
  그 자체로 하나의 역할을 맡고 있고,    
  자신이 하는 일을 명확히 표현하고 있다.    
  그리고 구현, 즉 변경될 수 있는 확률이   
  높은 부분은 내부로 한정되어 있으니(구현 부분)     
  변경이 있더라도 내부에서 관리가 가능하다.    
  외부에서는 변경을 알 수 없다.   
  단순히 작업을 요청만 하기 때문에.     
  
* 이렇게 캡슐화가 잘 되어 있는 객체들은     
  협력을 할 때도 그냥 요청만 하고, 거기에    
  대한 응답은 온전히 다른 객체에게 맡길 수     
  있게 된다. 왜냐, 캡슐화가 잘 되어 있기   
  때문에 자신이 맡은 책임을 잘 수행할 수 있다.       
  
* 인터페이스와 구현이 명확하게 분리되는 것은     
  결국 외부와 내부에 노출되어야 할 객체 내부의     
  상태와 행동이 잘 분리 되어 있다는 것을 의미한다.     
  
* 인터페이스는 외부에 노출하는 것으로     
  객체가 다른 객체와의 협력을 위해 최소한으로   
  노출하는 협력 수단이다.    
  자동차의 핸들, 브레이크, 액셀, 변속기 등이 인터페이스고,   
  리모컨의 버튼, 키보드, 마우스가 인터페이스이다.     
  위 것들은 내부의 상태를 인간이 이해할 수 있는    
  수준으로 추상화 하면서, 온전히 기능을 수행할 수 있게 한다.     
  
* 우리는 운전하기 위해 엔진의 상세한 구현을     
  알 필요는 없다. 그냥 액셀을 밟으면     
  앞으로 간다는 사실만 알고 있으면 된다.   
  이렇듯 구현의 복잡성을 몰라도 사용할 수 있는    
  것이 인터페이스고, 인터페이스에 의지해야     
  추후 구현이 변경 되어도, 신경쓰지 않을 수 있다.     
  
* 엔진이 바뀔 때 마다 운전법을 새로 배워야 한다면??     
  말이 안된다. 이래서 인터페이스에 의존해야 하며,     
  객체지향 설계 역시 인터페이스에 의지하는 설계를   
  해야 한다. 그래야 유연한 설계가 가능하다.        
  
* 구현은 곧 내부의 복잡성을 의미한다.     
  이를 감추는 이유는 외부에서 구현에    
  의지하지 못하게 강제하는 역할이다.   
  또한 외부로부터 상세한 구현을 감춤으로써    
  구현이 변경되어도, 외부에는 아무런    
  지장이 없도록, 똑같이 인터페이스에만   
  의지할 수 있도록 하는 것이 목적이다.      
  
* 결국 수정과 확장에 유연한 설계를 위해서이다.    
  설계의 유연함과 확장성을 위해서이다.    
  소프트웨어는 아무도 이용하지 않을 때 까지      
  끊임없이 변화해야 한다.    
  이 변화를 쉽게, 유연하게, 낮은 비용으로 유지하기     
  위해 객체지향 설계를 사용하는 것이다.     
  그렇기에 모든 객체지향 기법은 설계의 유연성과,    
  유지보수, 확장의 용이함을 위해서이다.     
  그리고 누구든지 작업할 수 있도록 하는 것이다.    
  소프트웨어는 혼자 만드는 것이 아니기 때문에.    
 
* 항상 명심하자. 좋은 설계는 유연하면서,    
  유지보수, 확장에 용이한 설계이다.    
  누구든지 코드를 보고도 명확하게 이해할 수 있고,     
  유지보수, 확장을 할 수 있어야 한다.      
  
* 결국 추상적인 것에 의지해야 하는 이유는     
  상세한 구현은 변경에 취약하기 때문이다.     
  요구사항의 변경은 늘 빈번하게 일어나고,     
  이러한 요구사항의 변경은 결국 구현의   
  변경을 요구한다.  
  
* 하지만 추상화에 의존하게 되면,    
  상세한 구현의 특징들을 모아    
  한 번 더 추상화 했고, 거기에    
  의존하기 때문에 상세한 구현이    
  변경 되어도, 추상화를 사용하는 부분은     
  변경하지 않아도 된다.  
  단지 추상화에 의존하는 구현체들만    
  변경해주면 된다.        
  
* 추상화를 사용하는 클라이언트는 어쨋든     
  컴파일 시점에는 어떤 구현체를 사용할 지    
  모른다는 단점이 있지만, 의존성이 런타임 시점에     
  결정되기 때문에 유연한 설계가 가능하다.    
  
* 트레이드 오프이긴 한데 코드를 조금 이해하기 힘들어도,    
  결과적으로 유지보수와 확장에 유연한 설계를 선택하는게      
  장기적으로 봤을 때 좋지 않을까 생각이 든다.        
  
* 추상화는 안정적이기 때문이다. 상세한 구현에서     
  공통된 부분을 한 번더 추상화 했기 때문에    
  안정되어 있고, 변경될 여지가 적기 때문이다.    
***
아침정리 끝
  
  
