# 오늘 공부한 내용 정리     
* 서블릿은 기존에 내가 웹서버를 만들 때 했던      
  비즈니스 로직을 제외한 모든 작업들을    
  자동화 해주는 프레임워크이다.    
  
* 즉 요청에서 httpHeader를 파싱하고, 요청을 나누고,      
  이를 분리해서 각각 알맞는 비즈니스 로직을 실행시키는    
  작업 모두 was에서 해주는 것이다.      
  
* 그렇기에 나는 reqeust 객체와 response 객체를    
  메서드의 매개변수로 전달 받아 그냥 사용하면 된다.    
  
* 처음 요청이 들어오면, 거기에 대해 request, response    
  객체를 생성하고, 요청 http header를 파싱해서 전부 가져    
  올 수 있기 때문이다.    
  
* 구조 역시 그냥 앞에서 요청 파싱해서      
  request 객체, response 객체 생상하고     
  우리가 사용할 수 있는 형태로 넘겨주는 것이다.     
  
* 아마 내가 웹서버를 만들 때 했던 작업을        
  추상화 시켜 놓았을 것이다.     
  
* 그렇기 때문에 개발자가 웹서버를 Socket으로 직접    
  띄울 때 했던 작업을 was 컨테이너에서 제공해 주는 것이다.     
  
* 분명 소모적인 작업이고, 요청이 다양해짐에 따라    
  확장이 불가피한 요소였는데 이러한 부분을 자동화    
  해준 것이다. was가.       
  
* 응답시에도 그냥 response 객체만 전달하면    
  was에서 해당 객체를 참고해 응답을 하게 된다.    
  
* 이로써 개발자는 비즈니스 로직에만 더욱   
  집중할 수 있게 되었다.
  
* 요청이 들어오면 서블릿 객체를 생성하게 된다.    
  이는 서블릿 컨테이너에서 이루어지는 작업으로      
  서블릿 객체를 생성, 초기화, 호출, 생명주기 까지    
  관리한다.    
  
* 서블릿 객체는 싱글톤으로 관리된다.   

* 매번 요청이 들어올 때 마다 객체를 생성하는 것은     
  비효율적이기 때문이다.      
  
* 컨테이너에서 미리 만들어두고, 이를 요청마다    
  재활용 하는 것이다.     
  
* 그래서 모든 요청은 동일한 서블릿으로 처리가    
  가능 한 것이다. 그렇기 때문에 싱글톤 객체를    
  이용해서 맴버 변수를 사용할 땐 주의해야 한다.    
  값이 어디서 변경 됬는지 모르기때문에.
  
* 그럼 요청이 들어오면 어떻게 실행 흐름을 만드는가.     
  바로 스레드를 이용하는 것이다.   
  내가 했던 웹 서버 구현에서 역시 Socket을 실행해     
  요청을 대기하고 있다가 요청이 들어오면 Socket 객체를    
  생성해 스레드를 상속 받은 클래스에 넘겨주면서    
  스레드를 실행시키게 된다.   
  
* 그럼 스레드가 돌면서 요청을 처리한다.   
  was도 처음 요청을 받으면 스레드를 실행 시키면서     
  작업을 진행하게 된다. 어짜피 서블릿 객체는     
  싱글톤이기 때문에 스래드가 요청에 처리할 때     
  서블릿 객체를 생성하는 것이 아닌 사용하는게    
  될 것이다.      
  
* 만약 여러 요청을 동시에 처리해야 한다면    
  어떻게 해야 할까? 매번 스레드를 생성하는 것은    
  좋은 방법이 아니다.     
  
* 왜냐, 스레드를 생성하는 것 자체가 리소스를     
  많이 사용하고, 스레드간의 컨텍스트 스위칭 비용이     
  많이 들기 때문에 매번 스레드를 생성하는 것은    
  좋은 방법이 아니다.    
  
* 해결책은 요청에 응답하는 스레드를     
  스레드 풀이라는 것을 사용해서     
  한 번에 사용할 만큼 생성해두고,    
  딱 그만큼만 사용하는 것이다.    
  
* 그렇게 되면 서버 가용량에 맞게     
  스레드를 생성해 요청을 받을 수 있고,      
  스레드의 무한 생성을 막을 수 있다.     
  
* 부하를 관리할 수 있는 범위 내에서      
  멀티 스레드 환경을 구현할 수 있다.    
  
* 그리고 이 작업을 was가 자동화를 해준다.    
  즉 개발자가 멀티스레드 환경을 구축하지 않아도         
  was 내부에서 멀티스레드 환경을 구축하고 있기    
  때문에 서버 용량에 맞게 max thread 양만     
  조절해주면 된다.   
  
* 항상 멀티 스레드 환경에서 주의할 것은     
  싱글톤 객체를 사용할 때이다.    
  
* 싱글톤 객체에서 전역으로 사용되는   
  멤버변수를 남발했다간, 값의 변경을     
  예측할 수 없어 이를 주의해서 사용해야 한다.    
  
* 동시성 문제가 발생한다. 그렇기 때문에     
  멀티스레드 환경에서 싱글톤 객체에 대한    
  동시성 문제를 항상 고려하자.
  
  
