# 오늘 공부한 내용 정리     
* 현재 프론트 컨트롤러를 통해 요청에 따라   
  구현체를 생성, 호출해 사용했다.   
  
* 이는 인터페이스에 의존하고 있기 때문에   
  가능한 것이었다. 어쨋든 프론트 컨트롤러는    
  클라이언트로써 컨트롤러 인터페이스에 의존하고 있었고,    
  상세한 요청에 따라 다형성을 이용해 구체적인     
  클래스를 주입받아 사용할 수 있었다.   
  
* 이번에 한 것은 뷰에 대한 중복된 코드를 걷어내는   
  작업을 진행했다.   
  
* 현재 각 컨트롤러는 jsp를 foword하는 코드가     
  모든 컨트롤러마다 있었고, 이는 경로가 바뀐다던가     
  했을 때 모든 컨트롤러의 작성된 viewPath를 바꿔줘야 하는     
  변경 전파를 의미하고 있었다.    
  
* 해서 프론트 컨트롤러에서 요청에 따라 구체적인      
  컨트롤러를 호출했을 때 리턴값을 view 객체를     
  받도록 컨트롤러의 인터페이스를 설계했다.   
  
* 이렇게 하면 각 컨트롤러에서는 자신이 비즈니스 로직을 수행하고,    
  직접 뷰를 호출할 필요 없이 경로가 적힌 뷰 객체만을 생성, 반환하면    
  프론트 컨트롤러에서 리턴 받은 뷰 객체를 rander class를 통해     
  forwording 하게 된다.     
   
* 이렇게 view 객체를 반환함으로써 컨트롤러에 중복되어 있던     
  뷰로 이동하는 코드를 깔끔하게 분리 가능하다.   
  
*  뷰 객체는 jsp 파일의 경로를 인스턴스 변수로 가지고,     
   실제 뷰를 forword하는 역할을 한다.    
   왜냐면 jsp 파일의 경로를 가졌으니, 당연히 해당 클래스에서     
   jsp 파일로 forword 하는 것이 맞다.   
   
* 컨트롤러에서는 해당 view 객체를 생성해 넣어줄 때    
  jsp 경로만 넣어주고 생성해주면 된다.     
  
* 그럼 컨트롤러 객체에서 각각 뷰를 forword 할 일이 없다.     

* 인터페이스 설계 역시 뷰를 반환하는 추상메서드를 추가하던,    
  새로 만들던 하면 된다. 또한 뷰가 현재는 jsp 파일이지만    
  다른 파일이나, 전송 양식이 있다면 뷰 객체 역시 인터페이스로     
  설계해 확장성을 지닐수도 있다.     
  
* 핵심은 뷰 객체를 새로 만듬으로써 컨트롤러에 jsp 파일을     
  forword 하는 코드의 대한 중복을 제거 했다는 것.     

* 프론트 컨트롤러에서 뷰 객체를 반환 받아      
  뷰 객체의 랜더링 메서드를 호출해 forword를 진행하는    
  흐름으로 바꼈다는 점이다.    
  
* 이렇게 함으로써 컨트롤러의 중복이 제거되고,     
  좀 더 컨트롤러 본문의 역할을 잘 할수 있게 됬다.     
  
* 프론트 컨트롤러는 반환받은 뷰 객체를 통해 바로     
  reader()를 호출하면 해당 컨트롤러가 초기화 한    
  jsp 파일을 forword 하게 되는 것이다.     
  
* 설계가 너무 깔끔하고, 아름답다...      

* 좋은 설계는 변경 포인트가 한 곳이어야 한다.     
  그 이유는 변경 포인트가 한 곳이라는 것은    
  해당 객체가 잘 설계 되었다는 증거이고,  
  응집도가 높고, 캡슐화가 잘 되었다는 뜻이다.    
  
  만약 변경 포인트가 두 곳 이상이라면    
  이는 좀 더 바꿔야할 곳이 있다는 뜻이다.        




![스프링 mvc v3](https://user-images.githubusercontent.com/60066223/112788605-34c8c880-9096-11eb-928d-c3d36f8d9130.PNG)        

* 위 이미지를 기반으로 복습을 진행해보려 한다.    
  * 해당 컨트롤러에서 중요한 변화는   
    1. 각 컨트롤러들의 서블릿 의존성을 제거      
    2. 각 컨트롤러마다 중복 됬던 jsp 파일     
       절대경로 제거      

  * 처음 요청이 들어오면 `Front Controller`에    
    요청이 도착한다.   
    모든 요청은 해당 Controller로 모인다.     
    
  * 상세한 url 주소를 `getResourceUrl()`로 출력해    
    미리 초기화 해 두었던 맵핑 정보가 담긴 map에    
    키로 전달, 해당 url에 맞는 컨트롤러 객체를   
    반환 받는다.   
    
  * 이는 인터페이스를 이용한 다형성으로 구현되어 있어    
    상세한 구현체를 상위 인터페이스 타입으로 받을 수 있고,         
    해당 구현체를 이용해 컨트롤러를 호출, 사용하게 된다.    
    
  * 컨트롤러는 modelView 라는 객체를 FrontController에    
    반환하게 되는데 이 modelView 객체는 jsp에 랜더링 할    
    데이터와, 상대경로가 담겨 있는 객체이다.       
    
  
  * 이렇게 하는 이유는 각 컨트롤러마다 jsp 파일의 절대경로를    
    전부 적어서 view 객체를 만들어 리턴하고 있었다.   
    이러다 보니 절대 경로 명이 바뀌거나, 경로가 바뀐다면    
    모든 컨트롤러를 찾아서 전부 이름을 변경해주어야 했다.    
  
  * 이렇다 보니 뷰 경로와 jsp에 랜더링 될 파일을 모아서     
    modelView 객체를 만들게 되었고, 각 컨트롤러에서는    
    절대 경로가 아닌 컨트롤러 고유의 상대적인 경로만을    
    modelView 객체에 담아 전송하게 된 것이다.         
    
  * 이 때 회원등록을 하게 되면 유일한 서블릿인 FrontController에서      
    request 객체로 등록된 회원에 대한 Model 객체를 생성하게 된다.    
    이유는 Controller 인터페이스의 구현채인 각 Controller 들에서     
    서블릿에 대한 의존성이 제거 됬기 때문에 직접 request 객체를     
    통해 값을 꺼낼수가 없다. 그렇기에 등록한 회원을 직접 저장하는         
    컨트롤러에는 model 객체를 FrontController에서 만들어서     
    매개변수로 넘겨 주어야 한다.    
    
  * 그렇기 때문에 인터페이스 스펙도, 매개변수는 Map이 하나 추가되고,     
    ModelAndView를 반환하는 것으로 변경된다.         
    
  * 컨트롤러로부터 ModelView를 반환받은 FrontController는     
    뷰 리졸버를 통해 jsp 파일 경로를 완성한다.    
    
  * 뷰 리졸버의 역할은 컨트롤러에서 ModelView 객체에 넘긴     
    상대경로를 받아, 이를 절대경로로 만드는 것이다.   
    그리고 이 경로로 뷰 객체를 만들어 최종적으로 랜더링    
    가능한 상태로 만든다.    
    
  * 위같이 뷰 리졸버가 추가됨에따라 각 컨트롤러에    
    중복됬던 절대경로를 뷰 리졸버로 한 번에 처리할 수     
    있게 됬으며, 뷰 객체의 생성도 따로 컨트롤러에서    
    하지 않게 됬다.    
    
  * 이렇게 절대 경로에 대한 중복을 없애고, 변경에    
    유연한 설계를 할 수 있게 됬다.    
    
  * 그리고 이 뷰 객체를 전달 받은 FrontController에서     
    뷰 객체를 랜더링 해 jsp를 통해 최종적으로 응답하게    
    되는 것이다.      
***
v3 까지 끝, v4, v5 추후 진행 
