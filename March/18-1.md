## 공부할 것   
* 객체의 비교, Comparator, Comparable     
* 자바 subList    
* 스트림       
* 중첩 for문을 사용하지 않는 법            
***
1. 객체의 비교, Comparator / Comparable의 차이         
  * **Comparable**은 compareTo()를 재정의 함으로써 사용할 수 있다.      
    해당 인터페이스의 특징은 내가 직접 정한 조건의 크고, 작음으로      
    객체를 정렬할 수 있다. 커스텀 객체(내가 생성해 사용하는 객체)       
    는 Comparable이 구현이 되어 있지 않으며, 이를 그냥         
    List<커스텀타입> 참조변수명.sort 해 버리면 에러가 난다.      
    
  * 객체의 많고 많은 필드 중에 도대체가,       
    무엇을 기준으로 정렬하란 말이냐!!! 하면서 에러가 난다.      
    그래서 객체에 Comparable 인터페이스를 상속 받아      
    compareTo() 를 재정의, 구현 해야 한다.      
  
  * 이 Comparable 인터페이스의 특징은 주어진 조건을 비교해   
    오름차순, 내림차순 정렬이 가능하다는 것이다. 
    
  * 기준, 즉 해당 메서드를 호출한 객체가 기준이고,  
    매게변수로 전달 된 객체가 비교대상이 된다. 
      
  * 오름차순 기준으로,    
    기준 객체가 매게변수 객체보다 크다. 그러면 1을 반환하면 된다.        
    같으면 0을 반환하면 된다.      
    -1을 반환할 경우 내림차순으로 정렬 하겠다는 의미이다.           
  * 이렇게 정해진 기준을 가지고 정렬을 수행하고자 한다면                           
    Comparable 인터페이스를 구현해 사용하자.                  
          
  * **Comparator**는 compare()를 재정의 해야 한다.                 
    정해진 기준이 아닌 사용자의 조건으로 정렬하고 싶을 때 사용한다.                
    
  * 일단 매개변수를 두 개 받는다. 이유는 따로 Comparator 인터페이스를 정의         
    하는 클래스를 만들게 되면 비교 대상과 기준 모두 전달 해야 하기 때문이다.       
    해서 이 두 대상을 내가 원하는 기준으로 만들어 정렬할 수 있다.           
    
  * 가령 키 순서대로 학생들을 줄 세우다가 키가 같다면 이름순으로 정렬해라.   
    라고 할 때 사용된다. 일단 키 순서대로 오름차순 하면서 키가 같을 때                              
    이름의 오름차순으로 정렬, 또 키 순서대로 정렬 이런식으로 진행해야 한다.                
    
  * 이럴 때 쓰이는 것이 Comparator 인터페이스이다.            
    
  * 만약 이 두 인터페이스를 기존 객체에 구현 받아 사용할 수도 있고,                
    무명객체로 생성해서 사용할 수도 있다. 인터페이스이기 때문에.                     
    
  * **Comparable**은 비교 타입의 자료형만 맞으면 타입은 신경쓰지 않는다             
    **Comparator**는같은 타입에 한해서만 비교가 가능하다.                             
    서로 비교대상 객체에 impliment로 구현했다고 가정 했을 때.                   
           
  * 그리고 String 같은 경우 따로 두 인터페이스를 구현하지 않아도 되는데            
    그 이유는 이미 String class 내부에서 두 인터페이스를 구현하고 있기 때문이다.          
***
* 자바 subList 란?        
  * List에서 인덱스로 범위를 지정해 그만큼의 List를 새로 만드는 함수이다.            
   
  * subList(여기부터, 여기까지(마지막 인덱스 값은 포함 안됨)) 이렇게 범위를 지정해주면             
    해당 범위의 값들을 가진 새로운 리스트를 반환한다.                 
  
  * 하지만 subList()의 단점이 있다.                
    1. 계속 parant를 생성한다는 것.              
       즉 subList()로 리스트를 생성하면               
       해당 리스트의 원본 리스트를 생성한다는 것이다.              
                 
    2. 기존의 원본 데이터를 수정하면 계속 연결되어 있기 때문에                 
       에러가난다. 즉 원본에 대한 자유도를 잃게 된다.              
   
  * 이를 극복하는 방법으로는 새로운 리스트 참조변수를 만들어 거기에 할당하는 것이다.                    
    List<String> sList = new ArrayList<>(원본리스트.subList(0, 5));              
              
  * 이런식으로 새로운 리스트를 만들어 작업을 하면 서로 연동되어 있지 않기 때문에                
    위 문제가 해결이 된다.                  
    
  * 리스트에서 범위를 지정해서 때어 내야 할 때 좋을 거 같다.     
