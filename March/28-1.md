# 오늘 공부한 내용       
* 서블릿 컨테이너      
  * 싱글톤으로 관리되는 서블릿 객체를     
    생성, 호출, 생명주기 관리등을 해주며,      
    매 요청마다 서블릿 객체를 생성해서     
    사용하는것이 비효율적이기 때문에     
    하나의 서블릿 객체만을 생성해    
    공유한다.    
    
  * 왜냐하면 request, response 객체는   
    매 요청시에 데이터가 달라지고,    
    요청이 달라지기 때문에 객체를 생성하는 것이    
    맞지만, 서블릿 같은 경우, 같은 로직을 수행    
    하는 객체 하나만 있으면, 해당 객체를 공유해    
    사용하면 되기 때문이다.      
    
  * 해서 비즈니스 로직마다 필요한 객체를 하나만    
    생성해서 서블릿 컨테이너에서 관리하고,    
    공유하면서 사용하는 것이다.     
    
  * 그렇기 때문에 인스턴스 변수의 경우 사용을     
    주의해야 한다. 이유는 해당 객체는 하나만    
    생성되어 공유되기 때문에 당연히 쓰레드간에    
    접근을 통해 값을 변경할 수 있다.     
    
  * 이렇게 되면 어디서 어떻게 변경되는지, 예측하기가   
    너무 힘들고, 원하는대로 값의 출력이 힘들기 때문에      
    전역변수를 사용할 땐 주의 하는 것이 좋다.     
    
  * 서블릿을 지원하는 was의 특징으로는    
    멀티스레드를 지원한다는 것이다.    
    
  * 멀티스레드란 하나의 요청에 하나의 스레드가    
    사용되고, 요청이 끝나기 전에 다른 요청이     
    들어온다면 그 요청 역시 동시에 처리할 수     
    있는 것을 말한다.   
    
  * 스레드는 하나의 작업 단위이고, 독립적인    
    작업단위이다. 단, 프로세스의 자원을     
    공유한다는 특징이 있다.     
    
  * n개의 요청이 들어올 때 n개의    
    스레드가 생성되는 것이다.    
    
  * 이 때 매번 요청마다 스레드를 생성해   
    사용하게 되면 리소스 낭비가 심해진다.     
      * 스레드를 생성하는 비용은 매우 비싸다.    
      * 스레드가 요청에 따라 무한정 생성되면     
        cpu의 임계점을 넘는 상황이 발생하고,     
        서버가 죽어버리게 된다.    
      * 늘어난 스레드간의 컨텍스트 스위치 비용이    
        크게 증가한다.     
        
  * 이러한 이유고 was는 멀티 스레드를 지원할 때     
    스레드 풀을 사용해 위 같은 문제를 어느정도    
    해결하고 있다.    
    
  * 스레드 풀이란 한 번에 스레드를 지정한 개수만큼    
    생성해두고, 요청이 왔을 때 풀에서 스레드를 꺼내     
    요청을 처리하고, 요청이 처리 된 스레드는 다시    
    스레드 풀로 반환된다.     
    
  * 이 경우 스레드가 요청에 따라 생성되는 비용을    
    낮출 수 있고, 이미 생성해 놓은 스레드의 개수    
    안에서 요청을 처리하기 때문에 컨텍스트 스위칭 비용도     
    cpu의 상황에 맞게 조절 가능하다.      
    
  * 즉 스레드풀을 이용한 멀티스레드 환경을 개발자가    
    따로 구축하지 않아도, was에서는 간단한 설정으로     
    이를 해결해 준다.   
    
  * 이 때 주의할 것은 멀티스레드 환경에서 서블릿 객체는     
    싱글톤으로 생성되어 공유되기 때문에         
    여러 스레드가 동시에 값을 변경할 수 있다.    
    이 때 순서가 보장되지 않음으로, 이 같은 사용은    
    주의를 하는 것이 좋다.     
