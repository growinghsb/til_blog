# 오늘 공부한 내용 정리    
* 스프링 프레임워크의 핵심 개념과 컨셉.    
  모든 기술은, 언어는 핵심 개념과 컨셉을     
  알아야 한다. 본질을 알고 사용해야 한다.    
  이를 이해하고 사용해야 한다.    

* 스프링의 진짜 핵심은      
  좋은 객체지향 프로그램을   
  만들 수 있도록 도와주는   
  프레임워크이다.   
  
* 자바 언어를 사용해서 애플리케이션을 만들 때   
  객체지향이라는 강력한 도구를 최대한 잘 활용   
  할 수 있도록 하는 프레임워크이다.       
  
* 좋은 객체지향 설계가 가능하도록 도와주는      
  프레임워크이다.       

* 현상은 복잡하다. 본질은 간단하다. 항상 본질을 쫒아라.       
***    
* 객체지향이란 소프트웨어를 명령문들의 절차적 나열로        
  보는 것이 아니라 개별적이고 자율적인 하나의 객체들의       
  협력을 통해 만드는 것을 지향하는 프로그래밍 설계 기법.    
  
* 국부론에 나온 이야기로, 못을 생산하는 절차가 10가지가 있는데        
  한 사람이 모든 절차를 다 수행해서 못을 만들면 한 사람 당           
  하루 20개 정도의 못을 만들 수 있다.      
  이렇게 10 사람이 일을 한다고 했을 때 하루 200개의 생산량을       
  가지게 되는 것이다.    
  
* 하지만 한 사람은 하나의 작업만 반복적으로 처리하면   
  10명이서 수백, 수천개를 하루에 만들어 낼 수 있다.   
  이게 분업이고, 객체지향을 이용해 프로그램을 만드는 이유이다.   
  
* 하나의 객체는 위에서 한 사람과 같다.    
  즉 하나의 객체는 하나의 책임만을 가진다.    
  그래야 효율적인 분업이 가능하고, 정량적으로   
  시간 계산이 가능해 작업 효율을 극대화 할 수 있다.    
  
* 만약 한 가지 일을 하는데 오래 걸리는 작업이 있다면   
  이 작업은 두 가지 일로 쪼개야 한다.      
  모든 작업 단위가 비슷한 시간을 가지고 진행될 수 있도록    
  최대한 쪼개는 것이 중요하다.   
  
* 이를 객체지향에 그래도 도입할 수 있다.    
  각 객체는 한 사람이고, 한 가지 일만 해야한다.   
  객체가 맡은 책임 역시, 당연히 한 가지여야 하고,   
  두 가지 이상 책임을 맡았다면 이는 나누어야 한다.    
  
* 이렇게 한 가지 일을 잘 하는 객체들을 모아     
  순서대로 정보를 처리해 가면서 프로그램을 만드는 것이다.    
  
* 그리고 이렇게 반복 작업을 하는 사람들은    
  언제든, 대체 가능하다.     
  
* 그렇게 어려운 작업도 아닐뿐더러, 배우는데    
  그리 오랜 시간이 걸리는 것도 아니기 때문이다.   
  
* 객체지향 세계에서 역시 마찬가지이다. 객체가 맡은   
  책임은 언제든 대체 가능해야 하고, 대체 시 리스크나    
  발생되는 문제가 적어야 한다.   
  
* 만약 변경 시 예상치 못한 문제들이 발생되고,   
  여러 곳에서 수정이 일어난다면 이는 잘못된   
  설계라 할 수 있다.   
  
* 딱 그 부분만 변경할 수 있도록 해야 한다.    
  확장에는 열려 있고, 변경에는 닫혀 있어야 한다.    
  
* 이 공장 이야기로 SOLID가 설명 가능하다.      
  이 공장 이야기는 객체지향을 비유하기            
  완벽한 이야기이다. 최고다.          
  
* 만약 -자 못을 만들다가 +자 못을 만들어야 할 땐??    
  -자 홈을 파는 작업순서 뒤에 |자 못을 파는 작업을     
  하나 추가하고, 인력을 한 명 추가하면 된다.    
  
* 그럼 끝이다. 하지만 절차지향에서는 모든 사람을    
  모아다가 교육을 하고, 모든 사람이 적응할 때 까지     
  생산성은 떨어지게 된다.    
  
* 하지만 객체지향에서는 한 사람만 훈련시켜서 익숙해졌을 때    
  작업에 투입하면 된다.    
  
* 여기서 중요한 것은 -자 홈을 파던 사람이 |자 홈을 파지 않는 것이다.   
  왜나, 하나의 책임만을 수행해야 하기 때문이다.   
  
* 작업이 하나 늘어나면, 당연히 하나의 객체를 생성해    
  확장하는 것이 옳다.   
  
* 작업을 두 개 이상 하게되면, 의존도가 높아지고,    
  전문성이 떨어지기 때문이다.    
  
* 이렇게 쉽게 +자 못을 만들 수 있게 되었다.   
  다른 사람들은 그대로 자기 할 일을 하면된다.    
  
* 오로지 바뀐 것은 확장한 그 작업과 추가된 한 사람뿐이다.    
  그 외에는 아무것도 바뀌지 않았다.    
 
* 다형성이란 상위 클래스 타입의 메시지를 하위 클래스에서    
  수행할 수 있는 것을 말한다.   
  클라이언트는 상위 클래스에 의존하고 있고,    
  클라이언트의 각 명령은 알맞는 하위 클래스의 메서드가    
  실행되게 된다.    
  
* 이는 소프트웨어의 유연함과 확장성을 가지게 된다.    
  클라이언트는 그냥 명령만 하면 된다.   
  이를 구현하는 쪽에서 어떤 구현체를 사용하더라도    
  온전히 클라이언트의 명령을 수행할 수 있게 된다.    
  
* 또한 클라이언트가 같은 요청을 처리하는 다른 구현체로   
  변경을 요청해도, 유연하게 대처 가능 하다.    
  클라이언트에서 뭔가 변할 것 없이, 유연하게     
  확장이 가능하다.     
  
* 유연하고 변경 용이한 것이 다형성이다.     
  역할과 구현으로 분리할 수 있게 된다.    
  클라이언트는 역할에만 의존하면 된다.    
  역할이란 클라이언트가 알 수 있는 추상화 된    
  개념이다. 구현이란 이 추상화된 개념을   
  구체적인 실행 프로세스로 만든 것을 말한다.    
  
* 역할에 의존한 클라이언트는 상세한 구현을    
  알 필요가 없고, 구현이야 어찌 됬든 자신이   
  원하는 결과만 볼 수 있으면 상관 없다.    
  
* 구현을 하는 쪽에서는 클라이언트의 요청에     
  자신만의 방식으로, 클라이언트의 개입 없이    
  처리가 가능하며, 변경, 확장시에도 클라이언트에게    
  영향을 끼치지 않고 가능하다.   
  
* 여기서 클라이언트는 사용자가 될 수도, 다른    
  객체가 될 수도 있다. 즉 추상화에 의존하는    
  모든 것들을 클라이언트라고 한다.     
  
* 역할과 구현을 분리하는 것의 가장 큰 장점은     
  클라이언트가 편해진다는 것에 있다.     
  
* 클라이언트는 역할에 의존하고, 상세한 구현은    
  신경쓰지 않음으로 늘 자신이 원하는 최상의 결과를     
  볼 수 있다. 그리고 피곤하게 상세한 구현을    
  알 필요도 없다. 자동차를 운전하는데 밟으면 간다는   
  사실만 알면 된다. 밟았을 때 어떤 절차로 가는건지는   
  알 필요가 없다.    
  
* 이로써 얻을 수 있는 장점은 면허를 하나만 따도 된다는 것이다.     
  만약 밟았는데 어떤 차는 앞으로 가고, 어떤 차는 뒤로 간다면??     
  이건 각 차종마다 면허를 따야 한다.   
  
* 하지만 클라이언트는 역할, 엑셀이라는, 앞으로 간다는 역할에만     
  의존하고 있기 때문에 이러한 불상사 없이 이 차, 저 차 탈 수 있다.      
  
* 또, 역할과 구현으로 나눔으로써 클라이언트의 무한한 확장이          
  보장된다. 상세한 구현을 모르기 때문에 확장이 자유롭다.      
  
* 다형성의 본질은 역할과 구현이라는 실세계의 개념을     
  객체지향 세계로 가지고 올 수 있도록 하는 것이다.      
  다형성을 이용해 클라이언트는 역할에만 의존할 수 있고,    
  실제 이용은 자유롭게 구현 클래스, 구현 객체들을     
  사용할 수 있게 된다.      
    
* 객체지향 세계에서 모든 객체는 클라이언트 이면서       
  서버이다. 즉 서버와 클라이언트가 동시에 될 수 있다.          
  모든 객체가 요청과 응답을 할 수 있기 때문이다.       
***  
* Ioc란?     
  * 제어의 역전을 의미한다.    
  
  * 제어의 역전이란, 각 객체가 자신이    
    협력을 위해 의존해야 할 의존관계를    
    직접 정하는 것이 아닌 외부의 프레임워크나       
    세팅에 의해 선택 되어지는것을 말한다.    
    
  * 즉, 나한테 제어권이 있지 않고, 외부에 있다, 해서    
    제어권이 역전됬다, 제어의 역전이라고 한다.     
    
  * 의존관계란 내가 협력을 하는데 있어서 필요한 객체를     
    참조 또는 생성하는 것을 의존관계가 있다고 표현한다.    
    
  * 일반적으로 객체의 의존관계는 단방향 의존관계로,    
    내가 참조하고 있는 객체를 나는 알지만, 상대방에서는    
    알 수 없는 것이다.    
    
  * 이렇게 협력에 참여하기 위해 각 객체는 의존성을 가지는데    
    내가 의존하기 위한 객체를 내가 선택하는 것이 아닌 외부에서   
    대신 주입을 해줌으로써 의존관계를 만드는 것을 제어의 역전이라고 한다.    
    애초에 나한테 제어권이 없기 때문이다.    
    
  * 이렇게 제어의 역전이 진행되면 객체는 의존성에 대해    
    신경쓰지 않아도 되고, 의존성을 명시할 필요 없이    
    100% 추상화에만 의존할 수 있다.    
    
  * 즉 추상화에 완벽하게 의존하고, 이 실행 흐름은     
    외부 프레임워크에 맡겨 제어권이 역전되는 것을    
    Ioc 제어의 역전이라 한다.    
***
* DI란?   
  * Dipendency Injection으로    
    의존성 주입이라 한다.   
    
  * 위에서 봤듯이 Ioc는 좀 더 큰 범위에서   
    개념을 설명 했다면 이 DI는 실제 객체에    
    필요한 의존성을 주입하는 것을 말한다.    
    
  * 이 필요한 의존성은 추상화에만 의존하고 있는 객체에    
    추상화를 구현한 구체 클래스, 구체 객체를 직접 주입해줌으로써,    
    (실제로는 구체 객체의 메모리 주소를 할당하겠지??)     
    실행 시점에 구체 객체의 메서드를 호출, 실행할 수 있게    
    되는 것이다.    
    
  * 여기서 의존관계에 대한 두 가지 종류가 있다.   
    1. 정적인 의존관계(정적 바인딩)     
      * 정적 바인딩이란(편의상 정적 바인딩이라 하겠다)    
        클래스의 의존관계를 컴파일 단계에서 직접     
        가시적으로 확인할 수 있는것을 말한다.    
        
      * 그리고 어떤 객체가 어떤 추상화에 의존하는지가      
        클래스 다이어그램으로써 나타난다.    
        
      * 이러한 것들을 정적 바인딩이라 한다.      

    2. 동적인 의존관계(동적 바인딩)     
      * 동적 바인딩이란 직접적인 의존관계가   
        가시적으로 드러나지 않는다.   
        클래스 다이어그램을 보면 어떤 추상화에    
        의존하고 있는지는 알 수 있지만    
        실제로 구현되는 구현체는 어떤 객체인지    
        알 수가 없다. 이는 런타임 시점이 되어   
        의존성을 주입 받아봐야 알 수 있다.    
        
      * 이렇게 컴파일 시점이나, 클래스 다이어그램으로    
        어떤 구현체를 통해 메서드를 실행하는지를     
        알 수 없는 것을 동적 바인딩이라 한다.    
        
      * 이는 실행이 되고, 의존성을 주입 받을 때라야    
        실제 어떤 구현체를 사용하는지 알 수 있다.   

  * DI란 실행 시점에 실제 사용할 구현체에 대한    
    의존성을 주입 받고, 주입 받은 객체의 메서드가    
    실행되는 것이다.   
    
  * 이 DI의 기반은 다형성이다. 클라이언트 객체의    
    타입은 추상화 클래스이다.   
    즉 구현체들의 부모 격인 클래스 타입으로 선언되어 있다.    
    
  * 그리고 다형성으로 인해 추상화 타입으로 선언된 객체에    
    해당 추상화 클래스를 구현한 구현체 객체의 인스턴스를     
    주입할 수 있는 것이다.   
    
  * 구현 객체들은 이미 부모로부터 추상 메서드를 재정의, 구현 했기   
    때문에 당연히 주입 받은 구현체들의 메서드가 실행된다.   
    부모 타입의 참조변수지만 부모의 추상 메서드를     
    구현했기 때문이다.     
    
  * 이 DI를 사용하면 추상화로 인해 실제 코드를 파악하기는    
    좀 어려워졌지만 실제 의존관계를 명시하지 않음으로써   
    의존성이 약해지게 된다.   
    
  * 의존성이 약해짐으로써 결국 확장과 유지보수에 용이한    
    유연한 설계를 가져갈 수 있다.   
    
  * 내가 구현체를 바꾸려고 할 때 클라이언트를    
    바꾸지 않아도 된다. 즉 변경 포인트가 한 곳으로   
    몰리게 된다.   
    
  * 또한 내가 해당 객체에 대해 자세히 알지 못함으로    
    해당 객체의 응집도가 올라가고, 변경시에도     
    내부적으로 변경하는게 외부로 전파될 일이 적다.   
    
  * 그렇기 때문에 의존성을 낮게 유지 하는 것이 중요하며,    
    DI는 이런 의존성을 효과적으로 관리하기 때문에   
    스프링 프레임워크의 필수적인 기술이다.   
