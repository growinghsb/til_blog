# 오브젝트 책 공부        
* 현재 시점에서 enter는 너무 많은 것을 알고 있다.    

* 또한 각 객체들이 요청을 주고 받는 것이 아닌    
  직접적인 값을 주고 받고 있다.    
  
* 그리고 서로서로 합성을 통해 강결합 되어 있으며,    
  이 상태에서는 변경 전파가 일어날 수 밖에 없는     
  설계이다.    

* getter, setter가 열려 있어 캡슐화가 약해지고,    
  무분별한 호출로 인해 의존관계에 있는 객체들은    
  서로를 너무 잘 알고 있다.   
  
* 어떤 값을 가지고 있고, 어떤 로직이 수행되는지 등을 말이다.    

* 이럴 경우 의존도가 높아져 OCP를 지키키 힘들며,    
  객체의 캡슐화 저해로 응집도는 낮아질 수 밖에 없다.     
  
* 결국 유연한 프로그램을 만드는데 실패한 설계이다.       
  여기 조금 덧붙이자면, 결제를 현금으로 했는데     
  카드로 하는걸로 코드를 변경하면, 해당 변경이 전파되어     
  Theater의 enter 역시 바꿔줘야 된다는 것이다.     
![movie 예제 사진 1](https://user-images.githubusercontent.com/60066223/112304862-59f9b780-8ce1-11eb-8a9f-e0cac716df7f.PNG)
       
           
           
* 이는 결국 높은 의존성을 가지게 되며,     
  강한 결합으로 추후 유지보수 및     
  확장을 힘들게 하는 요소가 된다.   
  
* 결합도가 높으면 높을수록   
  하나의 변경이 또 다른 변경을 낳고,    
  변경에 변경을 낳기 때문이다.     
***
* 현재 1차적으로 리팩토링이 진행 됬다.            

* 하나의 enter 클래스에 모든 작업이 처리됬던,    
  절차지향적 로직에서 벗어나 각 객체가    
  자신의 역할을 수행하고, 협력이 필요한 부분은    
  다른 객체에 요청함으로써 의존성을 낮추고,   
  응집도를 높힐 수 있었다.     
  ![예제 1 사진 2](https://user-images.githubusercontent.com/60066223/112309244-78ae7d00-8ce6-11eb-880d-a5dcac73816a.PNG)
![예제 1 사진 3](https://user-images.githubusercontent.com/60066223/112309249-79dfaa00-8ce6-11eb-8da3-fe566f08112b.PNG)
![예제 1 사진 4](https://user-images.githubusercontent.com/60066223/112309251-79dfaa00-8ce6-11eb-926e-cca83a0165b9.PNG)       



* enter 메서드는 다른 객체에 의존할 필요 없이     
  TicketSeller를 통해 ticket을 판매하고 있으며,     
  TicketSeller의 내부 구현이 변해도 영향이 미치지 않는다.    
  
* TicketSeller 역시 자신의 sellTo 메서드만 외부에    
  노출 시킴으로서 판매 라는 책임을 다하고 있다.    
  
* Audience 역시 Ticket을 사는데 있어서  주체가 되었다.    
  자신이 가진 가방에 자신이 접근해, 티켓을 넣고,  
  돈을 뻬고 있다.    
  
* 또한 buy 메서드 로직을 실행 하면서    
  외부의 참조 없이 자신이 가진 필드들을   
  활용함으로써 응집도가 높다 할 수 있다.      
  
* 항상 객체의 메시지를 통한 협력, 자율성에 집중하라.    
  객체가 자율성을 띈다 라는 것은 자신이 가진 상태(필드)에     
  대해서 변경할 수 있는 자유, 외부에 의해 변경되지 않을    
  자유를 말한다.    
  
* 만약 객체의 상태를 외부에서 변경하거나,    
  자율적이지 못한, 수동적인 객체라면   
  이는 리팩토링을 고려해 봐야 한다.   
  
* 또한 객체에게 명령하는 것이 아닌    
  값을 달라고 하고 있다면 이 역시      
  객체의 자율성을 해치는 게 된다.      
  
* 출력값이 달라지거나 내부 구현의 변경으로 인해    
  외부에 변경이 전파되고, 결국 Bag의 변경이    
  Audience의 buy 메서드에 영향을 끼치기 때문이다.    
***
* 해서 이렇게 리팩토링 할 수 있었다.    
  buy class에서 수동적이던 Bag class의 의존적이던 부분을     
  전부 Bag class에 hold 메서드로 넣고,      
  필요한 구현은 내부의 메서드들을 이용해 구현,    
  return 값을 넘기는 방식으로 구현이 됬다.    
![예제 1 사진 5](https://user-images.githubusercontent.com/60066223/112311385-fc696900-8ce8-11eb-9118-b3d4c2d39496.PNG)
![예제 1 사진 6](https://user-images.githubusercontent.com/60066223/112311387-fd9a9600-8ce8-11eb-9fc3-b0e77bfe18b8.PNG)



* 해서 Audience 역시 Bag class에 대한 의존도를 낮출 수 있었고,      
  Bag class는 자신의 상태에 책임질 수 있고, 그로인해    
  응집도를 높힐 수 있었다.       

* 이렇게 각 객체들이 자신의 상태에 책임질 수 있도록,     
  구현 함으로써 캡슐화를 높히고, 그로인해 자연스럽게     
  응집도는 높아지고, 결합도는 낮아지는 효과를 얻게 되었다.    
