# 오늘 공부한 내용
* 자바 main 메서드의 의미, public static void main(String[] args)                 
  * public, 접근 제어자이다.                             
  
  * 접근 제어자란 해당 메서드에 접근할 수 있는 권한을              
    지정하는 것으로, public은 어디서나, protected는 상속관계(어디서든) + 같은 패키지     
    아무것도 지정하지 않은 default는 상속관계(같은 패키지) + 같은 패키지      
    private 는 같은 클래스에서만 접근이 가능하다.     
  
  * static 이 붙은 필드나 메서드는 클래스에 고정된 멤버이다.    
    즉 컴파일 시점에서 JVM의 클래스 로더가 클래스를 클래스 영역에 올려둘 때    
    같이 올라가게 된다. 그래서 접근 제어자에 따라 다르겠지만 언제, 어디서든    
    접근이 가능하게 되는 것이다. 즉 해당 클래스의 인스턴스를 생성하지 않아도     
    해당 클래스 명.static 필드명, 메서드명으로 접근이 가능하다.    
    
  * static은 힙 영역에 등록된 것이 아니기 때문에 GC의 간섭을 받지 않는다.   
    그러다보니 프로그램이 시작되어, 끝날 때 까지 메모리를 차지하고 있으므로     
    남발하는 것은 좋지 않다.       
    
  * static 필드는 값을 재할당 할 수 있다. 이 땐 주의해야 할 것이     
    내 프로그램 어디서든 접근 가능하기 때문에 값을 막 바꾸는 것은    
    정말 위험하다. 어디서 바뀐 지 알기 매우 힘들기 때문이다. 
    
  * void는 반환타입을 의미한다. 즉 아무것도 반환 할 것이 없다라는 의미이다.   
    실제로 void를 int나 다른 타입으로 바꾸면 해당 메서드는 일반 메서드가 된다.      
    
  * 그도 그럴것이 java application은 항상 main 메서드에서 시작되서,      
    마지막에 main 메서드가 종료 블럭을 만나면 프로그램은 종료된다.    
    
  * 여기서 뭔가를 반환 한다는 것은 의미가 없다. 받을 메서드도, 어떤것도 없는데     
    뭔가를 반환 한다는 것 자체가 모순이기 때문이다.   
    
  * 자바의 main 메서드에서 public을 바꾸든, static을 빼든 뭘 하면   
    main 메서드의 기능을 상실하게 된다.      
    
  * 매개변수로 String[]을 입력받는 이유는 외부에서 값을 입력받기 위함이다.     
    첫 실행 시 외부에서 전달되는 값을 받아 사용하기 위함이다.     
    
  * 자바 프로그램을 이클립스를 통해 실행하면 컴파일러가 .java 파일을 .class파일로 만든다.    
    .class 파일은 바이트코드로 작성 된 인터프리터가 읽을 수 있는 형태로 변환된다.    
  
  * 그리고 이 때 컴파일러가 크기가 0인 String[]을 생성해 매개변수로 넣어주게 된다.   

  * 그 후 커맨드에서 값을 넣고 실행해보면 해당 매개변수를 이용해 입력한 값을 출력할 수 있다.     
  
* final이란              
  * final의 경우 값으 재할당이 불가능하다.               
    하지만 불변성을 띄는 것은 아니다.                 
                  
  * `private final Map<String, Integer> map = new HashMap<>();`                     
    선언 후 `map.set("1", 1);` 해보면 값이 들어간다.              
                  
  * 즉 분명 나는 빈 HashMap을 인스턴스를 할당 했는데                               
    값이 채워지는 것이다.                                  
                              
  * 이렇듯 상태가 변하는 걸 막진 않는다. 단지 같은 참조변수에                  
    다른 인스턴스를 할당하는 것을 막을 뿐이다.                 
             
  * 정리하자면 final은 해당 참조변수에 대해 값의 재할당을 막는 것이지                 
    해당 참조변수가 참조하고 있는 객체의 상태까지는 보장하지 않는다.                       
    
  
     
