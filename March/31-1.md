# 오늘 배운 내용 정리     
* 스프링 프레임워크의 핵심은 DispatcherServlet이다.    
  이게 앞에서 만들었던 FrontController이다.   
  요청에 대해 가장 먼저 반응하며, 요청을 분석,   
  알맞는 컨트롤러와 어댑터를 호출해 연결하고,   
  로직이 수행된 결과를 다시 ViewResolver를 호출해     
  응답까지 진행하게 된다.    
  
* 그리고 이 많은 작업을 하기 위해선 필연적으로    
  강한 결합이 발생하게 되는데 스프링 프레임워크의    
  DispatcherServlet은 핵심적인 의존성을 추상화에    
  의존하고 있기 때문에 확장시에도, 클라이언트인    
  DispatcherServlet에는 영향이 크게 가지 않을것으로   
  보인다. 분명 이 거대한 프레임워크를 계속해서   
  발전시켜 오려면 기본적으로 확장에 유연한 설계를   
  해야되기 때문이다.    
  
* 그 다음으로 중요한 것은 핸들러 맵핑과 핸들러 어댑터이다.    
  일단 여기서 핸들러란 컨트롤러를 말하는데 좀 더 범용적으로     
  쓰이며, 컨트롤러 보단 넓은 의미로 핸들러라 부르고 있다.      
  
* 핸들러 맵핑은 요청 url을 알맞게 처리할 수 있는    
  컨트롤러를 찾은 과정을 말한다 이 과정에서      
  요청을 처리할 수 있는 컨트롤러를 반환하게 된다.   
  
* 이 과정을 처리하는 것이 핸들러 맵핑이다.     
  이 맵핑에도 순위가 있는데 가장 높은 것은     
  어노테이션 기반의 핸들러이다. 즉 어노테이션으로    
  스프링 빈에 등록된 컨트롤러 객체를 찾아 반환한다.     
  
* 핸들러 어댑터란 위 핸들러 맵핑을 통해 반환 받은    
  핸들러에 맞는 어댑터를 찾아 연결하는 과정이다.   
 
* 이 과정이 필요한 이유는 서로 다른 타입의 핸들러들을     
  하나의 DispatcherServlet에서 모두 처리하기 위해 필요하다.    
  
* 어댑터의 역할은 연결이다. 실생활에서 어댑터를 생각해보자.    
  노트북에서 220v 콘센트에 직접적으로 연결할 방법이 없다.   
  애초에 사용하는 전류의 타입이 다르기 때문이다.    
  
* 그래서 노트북 충전기라는 어댑터를 이용하는데 어댑터의 한 쪽엔     
  220v 콘센트가, 한 쪽에는 노트북에 연결 가능한 단자가 장착되어 있고,      
  중간에 220v 전류를 노트북에 맞게 변환 해주는 변환기가 있다.    
  
* 이러한 역할을 하는 것이 어댑터이고,     
  프로그래밍에서의 어댑터 패턴 역시         
  동일한 역할을 하게 된다.      
  
* 각 컨트롤러마다 인터페이스를 구현한 방식이 다르고, 또     
  로직을 처리하는 방식이 다르기 때문에 서로 다른 컨트롤러들을     
  하나의 DispatcherServlet에서 처리하려면 어댑터가 필요한 것이다.   
  
* Controller 타입별로 어댑터가 지정되어 있고,    
  핸들러 맵핑을 통해 가져온 컨트롤러의 타입에 맞는   
  어댑터를 핸들러 어댑터에서 가져오는 것이다.    
  
* 그렇게 어댑터를 통해 컨트롤러의 로직을 실행하고,    
  DispatcherServlet에서는 서로 다른 컨트롤러 타입이라도     
  일일이 맞출 필요 없이 어댑터를 통해 실행하면서 일관성을    
  가질 수 있다.    
  
* 정리하면 요청 -> 핸들러맵핑을 통해 컨트롤러 타입 반환       
  -> 반환받은 컨트롤러 타입에 맞는 어댑터 찾고 ->       
  어댑터를 통해 연결된 컨트롤러 실행 -> 컨트롤러 로직 실행        
  -> 실행 결과 어댑터에 반환 -> 어댑터, DispatcherServlet에 맞게      
  변환해서 결과 반환 -> DispatcherServlet 남은 작업 처리후 응답.       
  
* 이 역시 객체지향의 다형성을 이용한 것이다.      
  동적 바인딩을 통해 런타임 시점에 실제 참조하고       
  있는 타입의 오버라이딩 된 메서드가 실행되는 것이다.       
 
* 뷰 리졸버는 위 작업을 통해 반환된 논리적인 뷰 이름을    
  실제 뷰 파일로 바꾸는 로직을 수행, 뷰 객체를 반환하는   
  작업을 한다.    
   
* 어쨋든 로직이 실행되고, 응답을 하기 위해서는 html 파일이    
  필요하다. 이 때 컨트롤러는 논리적인 뷰 파일명을 반환하게 되고    
  물리적인 전체 경로를 통해 실제 뷰 파일을 읽어 응답하기 위해서   
  뷰 리졸버가 필요한 것이다.   
   
* 그리고, 그렇게 절대경로를 통해 찾은 뷰 파일을    
  각 뷰 타입에 맞게 랜더링을 통해 최종적으로     
  응답을 하게 된다.     
   
* 뷰 객체는 여러 파일 형태로 구현되어 있다.    
  jsp를 지원하기도, 프리마커와 벨로시티,     
  액셀, RSS 피드등 다양한 뷰 객체를 지원한다.    
   
* 즉 위 뷰 객체들을 이용해 각 파일 형식에 맞게    
  랜더링 해 서버에서 응답할 수 있는 것이다.    
   
* 또한 뷰 리졸버는 핸들러 url 맵핑과 같이    
  컨트롤러 -> 어댑터를 통해 반환 된 뷰 이름을    
  기반으로 사용할 뷰 객체를 찾아준다.    
   
* 뷰 리졸버를 통해 어떤 뷰 객체를 반환받을 것인지      
  설정을 통해 지정할 수 있다. 즉 내가 jsp를 사용하는지   
  프리마커나 벨로시티 같은 템플릿 엔진을 사용하는지    
  등을 지정해둘 수 있다.   
  
* 지금은 아마 다른 방식으로 진행할 듯 하다.
