# 오늘 공부한 내용      
서블릿을 공부하는 이유는 현재 사용하는 스프링mvc가                         
서블릿 기반으로 동작하기 때문이다.                 

그리고 서블릿을 통해 스프링mvc를 만들어 보면서                  
스프링에 대한 이해를 더 높힐 수 있다.                      
    
내가 웹서버를 Socket을 이용해 만들었을 때                        
http 통신이나 요청, 응답이 어떻게 이뤄지는지,                
뭐가 불편한지를 알고, 서블릿을 배우는데              
훨씬 잘 이해가 된다.              

그렇기에 서블릿을 배우면서, 스프링 프레임워크를                  
좀 더 깊이 이해하는 시간을 가질 수 있을 듯 하다.            
***       
### 서블릿이란            
* 일단 내가 `Socket class`를 이용해 요청을 `inputStream`으로 받아              
  요청 메시지를 전부 잘라서 필요한데 사용했던 작업을              
  톰캣이라는 was가 servlet을 이용해 쉽게 사용할 수 있도록         
  지원해준다.                
  
* 이로써 개발자는 자바 코드로 비즈니스로직만을    
  작성하는데 집중할 수 있게 된다.       
  
* 일단 원래 세팅은 톰캣을 깔고, 서블릿 설정을 따로            
  해주어야 하지만 편의상 was가 내장되어 있는      
  springboot를 이용하고, 서블릿을 통해 예제 진행      
  
* `@ServletComponentScan` 을 통해 서블릿 객체, 리스너, 필터등의                 
  객체를 생성, 저장할 수 있도록 하는 어노테이션.              
  
* 위 어노테이션을 기반으로 서블릿 객체가 생성, 관리된다.             
  class에 `@WebServlet` 어노테이션이 있으면, 해당 클래스를    
  서블릿 객체로 생성, 싱글톤으로 관리하게 된다.               
  
* 그리고 name 속성에 서블릿 객체 명을 지정해주고,           
  urlPattern으로 어떤 요청 url과 맵핑될 것인지             
  지정하게 된다.             
  
* 만약 설정한 urlPattern이 `/hello` 라면                 
  `localhost:8080/hello` 요청을 했을 때                    
  관련된 urlPattern을 가진 서블릿 객체의              
  service 메서드가 실행되고, `request, response`                    
  객체를 사용해 요청과 응답을 처리하게 된다.         
  
* 서블릿은 결국 직접 http 요청 메시지를 파싱하고,            
  응답 메시지를 작성해야 했던 작업을 전부 자동화 해주고,       
  오직 비즈니스로직에 집중할 수 있도록 도와준다.            
  
* request 객체를 통해 다양한 요청에 관련된    
  정보를 알 수 있다.                
  
* 연결된 클라이언트와 현재 요청을 받는 port 번호또한      
  알 수 있다.              
  
* text만 주고 받을 때, 즉 http api 형식으로 데이터를          
  전송하면 서버는 `request.getStream()`을 통해 데이터를 얻어온다.          
  그리고 `StreamUtils` 라는 클래스의 `copyString()`       
  메서드를 통해 데이터를 문자열로 바꿀 수 있다.            
  이 때 매개변수로 stream 객체와, 인코딩 타입을            
  같이 넣어줘야 한다.        
  
* 인코딩 타입은 바이트 타입의 데이터를 문자열로 변환할 때               
  또 반대의 경우에 꼭 인코딩 타입을 지정해 줘야 한다.             
  그래야 한글이 깨지지 않고, 출력이 된다.                
   
* 만약 요청 데이터를 json 형태로 받고, 이를 객체로 바로                 
  변환하고 싶다면 스프링부트에서 지원하는 json 변환 라이브러리를          
  이용할 수 있도록 지원하는 `Object Mapper class`를 사용하면 된다.               
  
* 해당 라이브러리는 json 형태의 데이터를 객체와 맵핑해               
  json 형태로 응답이 오면 name 값과 맞는             
  클래스의 인스턴스 변수를 찾아서                 
  뒤에 value를 해당 인스턴스 변수에 넣는다.                  
    
* json -> 자바 객체로 바로 만들어 바꾸는 것이다.                 

* 이 때 ObjectMapper라는 클래스를 통해 진행되는데               
  예상으로는 json -> 객체 변환 라이브러리들을                       
  사용할 수 있게 추상화 해둔 클래스일 듯 하다.                     
  
* 해서 여러 라이브러리를 사용할 수 있도록                
  ObjectMapper class로 지원하는 거 같다.                
   
* 어쨋든 http body 데이터를 읽을 땐                 
  `Stream`을 통해 읽어오게 된다.                     
  그리고 해당 데이터를 객체로 변환하고 싶을 때          
  `ObjectMapper class`를 사용하는 것이다.           
  
* 이 때 json 형태로 데이터를 보내면         
  요청 시 http header에 content/type이                
  json으로 변경되어 있는 것을 볼 수 있다.              
  
* 보낼 때 json으로 보내도, 문자열 전체를 읽어올 땐        
  `Stream`으로 읽어오면 된다.              
  단, json 데이터를 바로 객체로 변환해,            
  값을 넣고, 객체를 생성할 땐            
  `ObjectMapper class`를 사용하는 것이다.           
  
* 이 때 `readValue()` 메서드를 사용하는데           
  `Stream`을 변환한 String 문자열과, 변환할           
  class 타입을 넣어주면 해당 클래스 타입의           
  객체에 값이 초기화 된 채로 객체가 반환된다.              
  이렇게 바로 객체를 변환, 생성 사용 가능하다.              
  
* 응답 하는건 http 응답 메시지를 작성하는거라 보면 된다.            
  쿠키값을 클라이언트에 저장해야 하면 쿠키 객체를                
  생성해 넣어주면 된다.            
  
* response 객체를 이용해 값을 셋팅해주면              
  해당 값들을 읽어들이고, http 응답 메시지를                 
  만들어 브라우저에 전달한다.               
  
* 그럼 브라우저는 응답 메시지를 받고,             
  클라이언트에 보여줄 html 파일을 랜더링 해            
  클라이언트에 보여주게 된다.             
  
* 상태코드를 지정해 보낼 수 있다.             
  
* 데이터를 보낼수도 있고, http 응답 메시지의                 
  여러 항목들을 직접 지정해 보낼 수 있다.                 
  
* 객체를 json으로 변환해 서버에 전송하기 위해서 역시                
  `ObjectMapper class`를 사용하게 된다.                
  
* 간단하다. 객체를 생성하고, 해당 객체를                   
  `ObjectMapper class`의 `writeValueAsString()`이라는                      
  메서드에 매개변수로 넣어 주면 `String`객체를 반환한다.              
     
* 그럼 그 String 객체를 그냥 response 객체를 이용해              
  클라이언트에 응답하면 끝이다.                  
***
### 클라이언트에서 어떻게 데이터를 서버로 전송하는가         
방식 1             
        GET 방식의 query parameter 를 통해 데이터를 전송한다.            
        이 때 url에 ?뒤에 부터 name-value 형태로 전달이 되며,            
        & 구분자를 통해 각 데이터를 구분하게 된다.      
        이는 클라이언트가 확인할 수 있는 형태로 url에 남게 되며     
        조회나 단순 저장을 요청할 때 사용되기도 한다.            
        
방식 2       
        POST 방식의 http 요청 바디에 데이터를 담아 전송한다.           
        이 때 데이터의 형식은 GET 방식의 query parameter와             
        유사하며, url에 노출되지 않은 형태로 서버로 전달되게 된다.             
        html form을 이용해서 서버와의 통신을 처리할 땐              
        GET, POST 방식밖에 없다.            
        주로 저장, 수정, 삭제등 데이터의 변경에 많이 쓰이며,           
        어디에든 쓰일 수 있지만 GET은 조회, 필터, 페이징에 쓰이고,           
        그 외에 데이터의 변경은 POST로 처리하게 된다.          
          
방식 3      
        http message body 즉 http api에서 많이 사용되는 방식으로          
        보낼 수 있는 데이터의 형태가 json, text, xml 등이 있지만           
        현재는 json으로 거의 통일되어 사용된다.        
        데이터만 실어 보내게 되며, 서버에서는 이를 따로 수신해       
        응답하게 된다. 이 땐 GET, POST 말고도 PUT, PATCH, DELETE 등의   
        http 메서드를 다양하게 이용할 수 있다.            
               
* 위 3가지가 클라이언트에서 전송하는 데이터의 전부이다.        
  위 3가지의 데이터를 서버에서 처리하는 방식을 배우면 된다.            
  
* GET 방식으로 http 요청을 했을 땐, request 객체를 통해           
  `getParameter()` 를 호출하고, 매개변수로, name 값을           
  적어주면, 해당 name 과 맵핑된 데이터를 반환한다.           
  
* 결국 핵심은 어쨋든 http request에서 필요한 데이터를            
  가져다 쓰는 것이다. 이렇게 편하게 가져다 쓰기 위해           
  이미 파싱을 해서 다 잘라서 저장하고 있는 것이다.          
  
* POST 방식으로 http body에 데이터를 실어 보낼 때 역시            
  `getParameter()`로 GET 과 같이 받으면 된다.           
  
* 이게 가능한 이유는 결국 서버로 전송되는                   
  qurey parameter는 형식이 같기 때문이다.     
   
* 다만 POST 방식으로 보낼 땐 보내는 데이터 형식에           
  좀 차이가 있다.                

* 그리고url에 노출 되는 것이 아닌           
  http body에 노출 되는 것도 GET 방식과의 차이이다.              
  
* 참고로 GET 방식으로 보낼 때 http body는 null 값이 된다.              
  GET 방식은 http body를 사용하지 않기 때문이다.                   
***
### 번외
* 번외로 서블릿 객체는 httpServlet 클래스를 상속 받아야 한다.            
  이 때 service 메서드를 오버라이딩 해 사용하게 되는데              
  해당 service 메서드는 protected를 생성해 사용해야 한다.               
  
* 이유는 캠슐화이다. 그리고 protected인 이유는            
  다른 패키지의 있는 상속관계에 있는 하위 클래스가             
  오버라이딩 해 사용할 수 있도록 지원하기 위해            
  protected로 접근 제어자를 지정해 준 것이다.            

* 만약 로그를 통해 http request message를 보고 싶다면           
  `logging.level.org.apache.coyote.http11=debug`를             
  properties에 세팅해주면 된다.       
***
* 정리     
  * 데이터를 서버로 전송할 땐 3가지 방법이 있다.    
    1. html qurey parameter(GET)            
    2. html message body(POST)        
    3. html massage body(Json)
  
  * 서버에서 클라이언트로 전송할 때    
    * 핵심은 응답 값들을 세팅해    
      내가 원하는대로 응답값을     
      설정할 수 있다는 것.      
      기본적으로 제공되는게 있긴 하지만     
      필요한 건 직접 값을 넣어줄 수 있다.     
      
    * 일반 텍스트를 그대로 전송할 수 있다.            
    
    * 객체를 Json 형태로 변환해 문자열을     
      클라이언트로 전송할 수 있다.    
      이 때 application/type은      
      json으로 지정해주면 된다.     
***
각 클래스에 @WebServlet이 붙으면 해당 클래스는       
서블릿 컨테이너가 관리하는 서블릿 객체가 되고,     
이는 싱글톤으로 하나만 생성, 관리되게 된다.     

처음 톰캣을 통해 요청이 들어오면          
request 객체와 response 객체를 생성해         
서블릿 객체에서 사용할 수 있도록 제공한다.     

그래서 서블릿 객체 내부에서 오버라이딩 된    
메서드를 만들어 매개변수로 넘어온       
request 객체와 response 객체를     
이용해 요청을 처리하고, 응답할 수 있게 되는 것이다.         

그리고 스프링은 이런 서블릿을 바탕으로     
좀 더 편하게 서블릿의 작업들을 진행할 수 있도록        
도와주는 프레임워크인 것이다.     
    
