# 오늘 공부한 내용 정리     
* 객체지향 프로그래밍은 이전에 있던     
  절차지향 프로그래밍의 부족한 점을       
  채우고자 나오게 되었다.      
  
* 기존에 절차지향은 관련된 데이터끼리 묶을 수 없고,     
  같은 부류의 데이터끼리 묶어야 하는 불편함이 있었다.     
  예시로 사람을 표현할 때 키, 몸무게, 나이등의 데이터를    
  하나로 묶어 한 사람을 표현하지 못하고, 키는 키대로       
  몸무게는 몸무게대로, 나이는 나이대로 묶어 보관했다.      
  
* 이렇게 되다 보니까 관련있는 데이터를 추출해 보기도 힘들고,     
  각 부류의 데이터가 잘못들어가도 실행해 출력해보기 전까지는     
  알 수 없는 불편함이 있었다. 이런 불편함을 해소하기 위해       
  구조체라는 것을 도입해 사용하게 되었다.     
  
* 구조체는 관련있는 데이터를 묶어 하나의 타입으로 정의하고,     
  해당 타입으로 각각 다른 데이터를 가진 구조체를 만들 수 있었다.    
  해서 관련있는 데이터가 하나의 구조체로 묶이게 되었고,     
  구조체를 통해 각각의 다른 데이터를 가질 수 있게 되었다.     
  
* 하지만 이런 구조체 역시 한계가 있었다. 어떤 문제냐면,       
  구조체를 사용하는 함수가 정리되어 있지 않고, 이곳저곳     
  흩어져 있어 뭔가를 수정하거나 어떤 흐름으로 실행되는지     
  파악하기 너무 힘들었던 것이다.     
  
* 그래서 이런 함수를 구조체가 선언된 파일안에 관련된 함수를      
  넣어 파일단위로 나누게 되었다. 어쨋든 문제가 어느정도      
  해결된 것처럼 보이지만 이를 언어 차원에서 지원할 수는 없을까?     
  하면서 나오게 된 것이 바로 현재 사용되는 객체지향 언어이다.      
***
* 객체지향은 확실히 인간친화적이며, 우리 인간이 세상을 바라보는     
  시선으로도 객체지향 세계를 어느정도 이해할 수 있다.      

* 인간은 세상의 거의 모든것을 물체로 인식한다.     
  이에 대한 근거는 우리가 이름 붙이지 않은 것이 없는     
  것을 들 수 있다. 정말 우리의 시선이 닿는 곳에 명사로 된      
  이름이 붙어 있는 것을 알 수 있다.     
  또한 우리나라 국어사전만 봐도 명사의 비율이 70%를 넘어간다..    
  정말 말도 안될 정도로 많은 명사 개수를 자랑하며, 이는    
  인간이 명사로써 사고 과정을 간단히 했다는 것을 알 수 있다.     
  
* 이런 명사 뒤에는 물체의 특징과 기능이 추상화 된채로      
  인간의 이해를 돕는다. 연필 하면 어떤게 떠오르는가?     
  밥솥하면? 각각 단어마다 떠오르는 추상적인 느낌이 있을 것이고,    
  이들을 설명하는 것은 특징(상태)과 기능일 것이다.       
  
* 또한 우리는 우리가 할 수 없는 행동에 대해 협력을 요청한다.     
  단적인 예로 대부분의 사람들은 스스로 머리카락을 자르지 않는다.     
  좀 더 전문적인 기술을 가진 미용사에게 머리카락을 자른다.     
  이렇게 자신이 할 수 없는 행동에 대해 협력을 요청하고,     
  미용사는 머리카락을 잘라 줌으로써 요청에 응답한다.     
  
* 그리고 머리카락을 자르러 갔을 때 우리는 모든 신상정보를     
  오픈하지 않는다. 미용사는 어떤 스타일로 머리를 자를 것인지     
  물어보고, 어떤 스타일을 원하는지 정도만 말해도 협력은     
  아무런 무리 없이 이루어진다.     
  
* 위 이야기에 객체지향의      
  중요한 개념이 모두 들어가 있다.            
  객체지향 세계에서 가장 중요한 것은 객체이고,     
  객체는 상태와 행동을 가진다.          
  객체들은 모두 역할에 맞는 책임을 가지며,     
  자신이 가진 역할에 맞게 협력에          
  참여할 책임이 있다.         
  
* 이게 진짜 말하고 싶은 핵심이다.      
  객체는 상태와 기능을 가지며,       
  이는 밀접한 관계를 가진다.     
  또한 모든 상태와 기능을 가지는 것이 아닌       
  프로그램에서 맡은 역할과 연관된 상태와     
  기능을 가지게 된다. 병원에서 사용되는     
  프로그램이라면 환자의 계좌번호는 필요하지 않을 것이다.     
  
* 또한 모든 객체는 협력에 참여해 각자의 역할을 수행한다.     
  미용사 역할을 맡은 객체는 고객의 머리카락을 깎아 줄     
  책임을 가지고 있으며, 협력에 참여할 의무가 있다.       
  
* 이렇게 맡은 역할에 맞는 책임을 지는데 필요한 상태와 기능을     
  가진 작고 응집도 있는 객체를 설계하는 것이 매우 중요하다.     
***
* 객체지향 프로그래밍이란 프로그램의 구성요소를 객체로 보고     
  이런 객체들의 상호작용과 협력으로 프로그램을 만들려는 노력이다.      
  여기서 노력이라고 한 이유는 모든 것이 객체는 아니기 때문이다.     
  단순히 데이터로 나타낼 수 있는 것은 데이터로 나타낼 수 있기 때문이다.     
  기본형 변수는 확실히 객체는 아니다. 이렇게 기본형 변수에도 데이터를      
  저장하고, 이동시킬 수 있기 때문에 노력이라 표현했다.      
  
* 객체지향 프로그램이 실행되는 방식은 기본적으로 객체들의     
  협력으로 프로그램이 만들어지고, 실행된다. 절차적 프로그램은    
  위에서 아래로 함수들을 통해 프로그램이 실행됬다면      
  객체지향 프로그램은 객체들의 협력을 요구하는 메시지를 통해    
  협력을 만들어내고 이런 상호작용을 바탕으로 프로그램을 만든다.     
  
* 또한 객체는 자신이 가진 상태를 자신의 기능으로 관리할 권리를 가진다.     
  즉 협력은 메시지를 통해서만 이루어지며 이 협력에 참여하는 방식은      
  객체가 결정한다. 자신이 가진 기능으로 상태를 변경하는 것이다.       
  즉 엄마 객체가 밥을 먹어라 메시지를 보내면 아들 객체는 자신이 가진     
  밥을 먹는다() 메서드를 이용해 밥을 먹고 스스로 몸무게를 weight += 0.1    
  증가시키는 것이다. 이런식으로 자신의 상태는 오직 자신의 기능에 의해서      
  변경되도록 설계 하는 것이 핵심이다.       
***
* oop 특성    
  * 캡슐화란 자신이 이 프로그램에서 맡은 역할에 맞는 책임을 질 때      
    관련된 상태와 기능을 모아놓은 것을 말한다.         
    그리고 정보은닉의 기능을 하기도 한다. 자신이 가진 데이터, 상태는    
    외부로부터 감추고, 협력에 참여하는 최소한의 공용 인터페이스만      
    외부에 노출해 협력에 참여하는 것이다. 머리카락을 자르러 가서     
    내 모든 신상을 공개할 필요는 없지 않는가? 마찬가지다. 상태를     
    외부로부터 감춤으로써 데이터를 보호하고, 객체의 자율성을 높힐 수 있다.      
    
  * 상속은 우리가 아는 상속보다는 진화의 개념이 더 가깝다. 실제로     
    상속을 하는 키워는 extends로 확장이라는 뜻을 가진 단어가 쓰인다.     
    상속이란 부모 클래스의 상태와 기능을, 이를 상속 받은 자식 클래스가     
    그래도 사용할 수 있으며, 거기에 더해 자식 클래스는 자신 고유의 상태와    
    기능을 추가해 사용할 수 있다. 이렇기 때문에 진화 및 확장이라 한 것이다.     
    
    상속의 순기능은 코드의 재사용성에 있다. 어쨋든 부모 클래스와 자식 클래스가    
    없다면 같은 코드를 두 번 작성해야 했지만 자식 클래스에서 부모 클래스의    
    기능을 사용할 수 있기 때문에 같은 코드를 두 번 작성하지 않아도 된다.     
    이로써 중복을 줄이고, 코드를 재사용할 수 있게 되었다.        
    
  * 다형성은 객체지향의 핵심적인 기능이다. 다형성이란 하나의 메서드를         
    각각 다른 객체가 각각 다른 방식으로 정의해 사용할 수 있는 것을 말한다.        
    그리고 하나의 타입으로 각각 다른 객체들을 참조할 수 있다는 것이다.        
    이는 상속으로 가능한 부분인데 부모 객체를 상속 받은 객체들은 부모타입        
    참조변수에 의해 참조될 수 있다. 물론 기능에 제한이 있기는 하지만      
    어쨋든 타입이 다름에도 불구하고 부모 클래스이기 때문에 이게 가능한 것이다.     
    이를 활용하면 추상화를 통한 확장이 매우 용이하고, 훨씬 유연한 프로그램을       
    만들어 나갈 수 있다.      
  
  * 마지막으로 추상화가 있다. 추상화는 일반화 시키는 거라고 볼 수 있을 거 같다.     
    여기서 일반화는 복잡한 팩트는 각설하고 당장 눈에 보이는 큼직한 특징을 가지고      
    해당 물체, 현상등을 규정하는 것을 의미한다.     
    추상화 역시 마찬가지이다. 사람 객체, 들어갈 특징들, 기능들이 너무 많다.    
    이걸 모두 넣었다간 결코 프로그램을 완성할 수 없을 것이다.       
    들어가야할 상태와 기능을 결정하는 기준은 어떤 프로그램인지, 이 프로그램에서    
    해당 객체가 맡은 역할과 역할에 맞는 책임을 수행할 때 필요한 기능과 상태만을    
    추상화 해 객체를 만드는 것이 중요하다.     
    
    이런 데이터 적인 관점 말고도 프로그램 관점에서 추상화도 진행할 수 있다.      
    추상적이라는 것은 구체적인 것을 설명하기에 좋다. 하지만 마냥 추상적일 수는 없다.    
    어느순간 분명 구체적인 것이 필요하다. 프로그램에서도 추상적인 객체를 만들고       
    외부에서 협력에 참여할 땐 추상적인 객체를 이용해 협력을 진행한다.     
    그리고 실제 코드가 구현되는 구체적인 부분은 외부로부터 감춘다.     
    이렇게 추상화를 진행할 수 있다. 이렇게 하는 이유는 유연성을 높히고,     
    변경 및 수정에 용이하게 하기 위해서이다.         
    왜 이렇게 되는지는 뒤에서 적는게 나을 거 같다.      
