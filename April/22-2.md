# 오늘 배운 내용 포함한 일기 작성     
* 오늘 프로그래밍 기초에서는 묵시적 형변환(암묵적 형변환)       
  자동 형변환, 명시적 형변환, 그리고 연산자에 대해 공부했다.       
  일단 묵시적 형변환이란 프로그래머가 따로 형변환에 대해 명시하지       
  않아도 컴파일러가 형변환 해 타입을 맞춰 주는 것을 의미한다.       
  즉 변수와 값이 서로 타입이 다르지만 타입을 맞춰 대입을 진행한다.      
  대게 묵시적 형변환은 작은 타입에서 큰 타입으로 넣을 때 가능한 거 같다.         
  
  그러고 보니 자동형변환 역시 묵시적 형변환과 같다는 생각이 든다.      
  묵시적 형변환 역시 프로그래머가 명시하지 않아도 자동으로 형변환 해    
  대입해주는 것이고, 자동 형변환 역시 같기 때문이다.       
  다시한 번 반복하지만 묵시적 형변환의 특징은 작은 값에서 큰 값으로     
  즉 값의 손실이 없을 경우 진행된다는 점이다. C#의 경우 큰 값에서     
  작은 값으로 묵시적 형변환을 하려고 한다면 컴파일 에러를 보낸다.      
  
  어떤 경우든 프로그래머가 의도한 것이 아니라 실수로 보고 컴파일에러를    
  통해 알려주는 것이다. 만약 내가 의도 했다면 명시적으로 타입을 적어주면    
  된다. (변환하고자 하는 타입) 이렇게 괄호를 통해 명시적 형변환을 해주면      
  프로그래머가 의도한 것으로 알고 값의 손실이 있더라도 형변환을 진행한다.     
  
  하지만 상수(키워드가 붙지 않은 수가 값인 상태)는 형변환이 불가능 하다.     
  애초에 수가 값인 상태의 상수는 그 자체로 상수이기 때문에 변환이 불가능하다.      
  ```C#        
  long lNum1 = 100_000_000_000;     
  int iNum1 = (int) lNum1; // 이건 가능하다, 변수에 있는 값을 읽어 형변환 하는건.      
  int iNum2 = (int)100_000_000_000L; // 이건 불가능하다. 수가 상수이기 때문에 변환 불가능      
  ```
  대게 묵시적 형변환은 작은 타입에서 큰 타입으로 진행된다고 보면 되고,        
  값의 손실이 있을 수 있는 형변환의 경우 명시적으로 변환하고자 하는       
  타입을 적어 주어야 한다.            
  
* 연산자도 배웠는데 사칙연산을 하는 연산자는 +, -, *, /       
  이렇게 4가지가 있다. 몰랐던 사실로는 정수값을 실수형 변수에     
  대입하게 되면 그대로 보존이 된 상태로 저장이 된다는 점이다.     
  표현범위 때문인지 값을 그냥 저장해버리는 여유를 보여주기도 한다.     
  
  산술 할 때 역시 자동 형변환이 적용된다. 이는 좀 더 정확한 값을      
  표현하기 위함임을 예상할 수 있었다. 정수, 정수 계산시엔 당연히    
  정수로 나오는 것이 맞지만 실수가 끼는 순간 모든 값은 실수로 나오게 된다.     
  
  이유는 정수는 실수를 표현할 수 없으므로 부동소수점 아래 자리를 그냥 버리는       
  경향이 있다. 반올림, 내림이 아니라 그냥 부동소수점 아래 비트를 날려 버리는 듯 하다.     
  
  그렇기 때문에 값의 정확성을 위해 계산 과정에 실수가 들어 있다면      
  실수값으로 반환한다. 그렇기 때문에 실수가 있는 계산의 결과를    
  정수형 변수에 저장하고자 한다면 형변환의 대상이 되어 부동소수점 아래 자리가    
  날라 가거나 int에 double를 넣으려 한다면 컴파일 에러를 만날 수 있을 것이다.      
  
* 또 연산자중에 증감연산자라는 친구에 대해 좀 더 상세하게 알게 되었다.       
  ```java     
  int iNum = 10; // iNum 이라는 변수에 10이라는 정수값을 저장했다.
  ++iNum; 
  iNum++;    
  // 이 두가지가 증가연산자이다. 물론 감소연산자도 있다.     
  // 하지만 결국 더하고, 빼고 차이기 때문에 증가 연산자로 설명하겠다.       
  
  /*
  ++가 앞에 있는 친구를 전위형, 뒤에 있는 친구를 후위형이라 부른다.      
  자세하게 알아보기 전에 왜 이 친구들을 사용하는지 간단하게 알아보고     
  가겠다. 이 친구들을 사용하는 이유는 ++가 기계어에 바로 매칭되는    
  명령어이고, 이로 인해 결국 iNum = iNum + 1; 과 같지만      
  성능면에서 이점이 있기 때문에 사용하는 것이다. 그리고 보기에도 편하다. 짧고.     
  
  그럼 이제 어떤 차이가 있는지 알아보도록 하겠다.       
  전위형은 먼저 1을 더하고, 다음에 대입을 한다는 의미이다.     
  후위형은 먼저 대입하고, 다음에 1을 더한다는 의미이다.      
  즉 위 계산은 총 두번의 실행흐름을 가지는데 전위형은 먼저 더하고,       
  대입을 하고, 후위형은 먼저 대입한 다음 값을 더한다.      
  끝이다. 이 차이다. 어짜피 대입할 변수가 없다면 상관 없지만    
  1을 더해 다른 변수에 대입해야 할 때 상황에 맞게 사용할 수 있을 거 같다.       
  후위형의 경우 int iNum2 = iNum++; 이렇게 하면 기존 10이 대입이 된다.      
  */
  ```         
  
* 또 비트 연산자라는 매우 재미있는 놈을 배웠다. 원래 그냥 넘어갔는데     
  이번 기회에 새로 배웠고, 매우 신기하고 흥미로운 아이였다.     
  이 비트 연산자 때문에 컴퓨터에 대해 좀 더 알고 싶어졌고, 이진수에    
  익숙해지고 싶어졌다.        
  
  간략하게 비트연산자에 대해 설명하면 and, or, xor, not 이렇게     
  4가지의 연산자가 있고, 각각의 연산자를 이용해 비트를 연산하는 것이다.       
  즉 정수값으로 변수를 선언해도 실제 계산은 해당 변수들의 비트값이 계산되어      
  값이 나오게 된다. and 는 계산하는 비트가 모두 1 일때만 1로 계산하고,      
  둘 중 하나라도 0이면 0으로 계산한다.      
  or 연산자는 둘 중 하나라도 1 이면 1 로 계산하고, 둘 다 0일때만       
  0으로 계산한다. 이 or 연산자는 정수를 그대로 더하는 것과 같다.        
  ```java    
  int iNum1 = 10;
  int iNum2 = 20;
  
  System.out.print(iNum1 | iNum2 == iNum1 + iNum2);
  ```
  위 출력값이 true 즉 같다라는 것이다. 모두 30이다.          
  xor 는 서로 다르면, 즉 하나는 0, 하나는 1 이라면        
  1 로 계산하고, 모두 1 이면 0으로 반환한다. 모두 0이면      
  0을 반환한다. 즉 or 의 반대라고 생각하면 된다.      
  not 은 ~로 표현하는데 모든 비트를 반대로 바꾼다.      
  즉 0 은 1로, 1 은 0으로 바꾸는 것이다.      
  이렇게 되면 기본적으로 음수가 양수가 되고, 양수가 음수가 된다.     
  왜냐, 맨 앞의 부호비트가 바뀌기 때문이다. 0이면 양수인데      
  0을 1로 바꾸니 음수가 되고, 1이면 음수인데 0으로 바꾸니     
  양수가 되는 것이다. 그리고 그 뒤에 비트도 모두 바뀐다.       
  
* 마지막으로 비트 이동 연산자를 배웠다. 비트 이동 연산자란     
  비트를 왼쪽, 오른쪽으로 이동시킬 수 있는 연산자이다.    
  재밌는게 비트를 왼쪽으로 이동시키면 x2 가 되고,       
  왼쪽으로 이동시키면 /2 가 된다는 것이다.        
  
  이렇게 되는 이유는 이동이 의미하는 것이 곧 자릿수의 증가이기 때문이고,        
  자릿수의 증가는 값이 2배가 된다는 것이다. 왜냐, 0 과 1 두 개를 표현할 수     
  있기 때문에 자릿수는 2 배수로 늘어나게 된다 10의 자리에서 자릿수가 증가하면     
  10배가 되는 것과 같은 원리이다.      
  오른쪽으로 이동하면 자릿수가 낮아지니 /2 한 것과 같다.          
  
  그리고 비트를 이동시키면 밀려나는 비트들이 있다. 해당 비트들은 그냥 버린다.     
  버리고 미는 반대 방향에 생기는 빈 공간은 0으로 채우게 된다.      
  
* 사실 객체지향 공부한 것도 잔뜩 있는데 이건 유튜브로 찍어 올려야겠다.       
  일기 형식으로 쓰니까 훨씬 잘 이해되고, 쓰기도 편하다. 이야기 하듯이      
  오늘 공부한 내용을 남기는게 효과적인 거 같다. 내가 이해하지 못한것도    
  적을 수 있고 하루 회고도 할 수 있으니 말이다.       
  지금 스터디 끝나고 돌아가는 지하철인데 하루하루에 일희일비 하지 말자.      
  내 성공은 이미 정해져 있고, 시간 문제일 뿐이다. 나는 내가 인생에서      
  원하는 모든 것을 성취할 수 있다. 오히려 이런 사실을 망각하고,     
  급하게 가려고 하다보면 중요한 것들을 놓치고 다시 돌아와야 한다.       
  우직하게, 꾸준히 앞으로 나아가라. 천천히 그러나 의미있게. 잘하고 있다.
  
