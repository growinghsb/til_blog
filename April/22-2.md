# 오늘 배운 내용 포함한 일기 작성     
* 오늘 프로그래밍 기초에서는 묵시적 형변환(암묵적 형변환)       
  자동 형변환, 명시적 형변환, 그리고 연산자에 대해 공부했다.       
  일단 묵시적 형변환이란 프로그래머가 따로 형변환에 대해 명시하지       
  않아도 컴파일러가 형변환 해 타입을 맞춰 주는 것을 의미한다.       
  즉 변수와 값이 서로 타입이 다르지만 타입을 맞춰 대입을 진행한다.      
  대게 묵시적 형변환은 작은 타입에서 큰 타입으로 넣을 때 가능한 거 같다.         
  
  그러고 보니 자동형변환 역시 묵시적 형변환과 같다는 생각이 든다.      
  묵시적 형변환 역시 프로그래머가 명시하지 않아도 자동으로 형변환 해    
  대입해주는 것이고, 자동 형변환 역시 같기 때문이다.       
  다시한 번 반복하지만 묵시적 형변환의 특징은 작은 값에서 큰 값으로     
  즉 값의 손실이 없을 경우 진행된다는 점이다. C#의 경우 큰 값에서     
  작은 값으로 묵시적 형변환을 하려고 한다면 컴파일 에러를 보낸다.      
  
  어떤 경우든 프로그래머가 의도한 것이 아니라 실수로 보고 컴파일에러를    
  통해 알려주는 것이다. 만약 내가 의도 했다면 명시적으로 타입을 적어주면    
  된다. (변환하고자 하는 타입) 이렇게 괄호를 통해 명시적 형변환을 해주면      
  프로그래머가 의도한 것으로 알고 값의 손실이 있더라도 형변환을 진행한다.     
  
  하지만 상수(키워드가 붙지 않은 수가 값인 상태)는 형변환이 불가능 하다.     
  애초에 수가 값인 상태의 상수는 그 자체로 상수이기 때문에 변환이 불가능하다.      
  ```C#        
  long lNum1 = 100_000_000_000;     
  int iNum1 = (int) lNum1; // 이건 가능하다, 변수에 있는 값을 읽어 형변환 하는건.      
  int iNum2 = (int)100_000_000_000L; // 이건 불가능하다. 수가 상수이기 때문에 변환 불가능      
  ```
  대게 묵시적 형변환은 작은 타입에서 큰 타입으로 진행된다고 보면 되고,        
  값의 손실이 있을 수 있는 형변환의 경우 명시적으로 변환하고자 하는       
  타입을 적어 주어야 한다.            
  
* 연산자도 배웠는데 사칙연산을 하는 연산자는 +, -, *, /       
  이렇게 4가지가 있다. 몰랐던 사실로는 정수값을 실수형 변수에     
  대입하게 되면 그대로 보존이 된 상태로 저장이 된다는 점이다.     
  표현범위 때문인지 값을 그냥 저장해버리는 여유를 보여주기도 한다.     
  
  산술 할 때 역시 자동 형변환이 적용된다. 이는 좀 더 정확한 값을      
  표현하기 위함임을 예상할 수 있었다. 정수, 정수 계산시엔 당연히    
  정수로 나오는 것이 맞지만 실수가 끼는 순간 모든 값은 실수로 나오게 된다.     
  
  이유는 정수는 실수를 표현할 수 없으므로 부동소수점 아래 자리를 그냥 버리는       
  경향이 있다. 반올림, 내림이 아니라 그냥 부동소수점 아래 비트를 날려 버리는 듯 하다.     
  
  그렇기 때문에 값의 정확성을 위해 계산 과정에 실수가 들어 있다면      
  실수값으로 반환한다. 그렇기 때문에 실수가 있는 계산의 결과를    
  정수형 변수에 저장하고자 한다면 형변환의 대상이 되어 부동소수점 아래 자리가    
  날라 가거나 int에 double를 넣으려 한다면 컴파일 에러를 만날 수 있을 것이다.      
  
* 또 연산자중에 증감연산자라는 친구에 대해 좀 더 상세하게 알게 되었다.       
  ```java     
  int iNum = 10; // iNum 이라는 변수에 10이라는 정수값을 저장했다.
  ++iNum; 
  iNum++;    
  // 이 두가지가 증가연산자이다. 물론 감소연산자도 있다.     
  // 하지만 결국 더하고, 빼고 차이기 때문에 증가 연산자로 설명하겠다.       
  
  /*
  ++가 앞에 있는 친구를 전위형, 뒤에 있는 친구를 후위형이라 부른다.      
  자세하게 알아보기 전에 왜 이 친구들을 사용하는지 간단하게 알아보고     
  가겠다. 이 친구들을 사용하는 이유는 ++가 기계어에 바로 매칭되는    
  명령어이고, 이로 인해 결국 iNum = iNum + 1; 과 같지만      
  성능면에서 이점이 있기 때문에 사용하는 것이다. 그리고 보기에도 편하다. 짧고.     
  
  그럼 이제 어떤 차이가 있는지 알아보도록 하겠다.       
  전위형은 먼저 1을 더하고, 다음에 대입을 한다는 의미이다.     
  후위형은 먼저 대입하고, 다음에 1을 더한다는 의미이다.      
  즉 위 계산은 총 두번의 실행흐름을 가지는데 전위형은 먼저 더하고,       
  대입을 하고, 후위형은 먼저 대입한 다음 값을 더한다.      
  끝이다. 이 차이다. 어짜피 대입할 변수가 없다면 상관 없지만    
  1을 더해 다른 변수에 대입해야 할 때 상황에 맞게 사용할 수 있을 거 같다.       
  후위형의 경우 int iNum2 = iNum++; 이렇게 하면 기존 10이 대입이 된다.      
  */
  ```         
  
* 또 비트 연산자라는 매우 재미있는 놈을 배웠다. 원래 그냥 넘어갔는데     
  이번 기회에 새로 배웠고, 매우 신기하고 흥미로운 아이였다.     
  이 비트 연산자 때문에 컴퓨터에 대해 좀 더 알고 싶어졌고, 이진수에    
  익숙해지고 싶어졌다. 
  
