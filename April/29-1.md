# 객체지향 스터디 내용            
* getter/setter, 캡슐화, 상속과     
***
* 토론 주제 :    
   * 캡슐화란 무엇인가?     
   * 캡슐화는 꼭 해야 하는가?      
   * getter, setter 는 어떨 때 사용하며,     
     setter 에 대한 생각은?       
     
* getter/setter 의 쓰임은 캡슐화의 정보은닉과 관련있다.     
  객체는 데이터와 기능을 가지는 독립적인 존재로, 다른 객체와의    
  협력을 하게 된다. 여기서 가장 중요한 것은 협력을 한다는 관점인데       
  협력할 때 가장 중요한 것은 객체의 기능이며, 올바른 상태를 가지는 것이다.      
  
  올바른 상태를 가지기 위해서는 객체의 생성 시점에 개발자가 의도한 값을     
  가질 수 있도록 초기화 해 주는 것이 중요하며, 접근제어자와 getter/setter       
  를 잘 사용해 객체의 캡슐화를 지키는 것이 중요하다.      
  즉, 객체의 데이터를 보호하고, 협력만을 위해 기능 몇 가지만 외부로     
  노출 시키는 것이다. 이게 캡슐화의 본질이다. 온전한 객체를 위해,      
  원활한 협력을 위해 객체의 데이터는 외부로 부터 감추고, 최소한의      
  기능만 노출 하는 것이다.     
  
  캡슐화를 하면 좋은 점     
  1. 객체의 데이터를 외부로부터 보호할 수 있다.      
     * 보호해야 하는 이유는?     
   
  2. 객체의 상태는 객체가 책임질 수 있게 되므로     
     프로그램 전제적으로 유연성이 증가되며,      
     상태에 책임지는 자율적인 객체가 된다.     
      * 상태에 책임지면 어떤게 좋은가?     

  캡슐화를 하지 않으면?     
  1. 어디서나 객체의 데이터에 접근해 객체의 상태를 변경할 수 있다.    
     * 이렇게 되면 안되는 이유는?     
  
  2. 모든 상태와 기능이 노출 되어 있으므로 변경에 취약하다.    
     초기 객체 설계자의 의도와는 다르게 쓰일 수 있다.     
     즉 실수하기 쉬운 코드가 된다.      
     
  3. 객체와 객체간의 협력이 강한 결합도를 가지게 될 가능성이 있다.     
     강한 결합도는 필연적으로 객체를 수동적으로 만들고,     
     전체적인 프로그램의 유연성을 떨어뜨려 유지보수를 힘들게 한다.       
     * 이렇게 되면 안되는 이유는?         
### 토요일 오전에 오브젝트 예제 추가해서 캡슐화 보충
***
* 상속에 대한 내용      
  * 상속이란 무엇인가?    
    상속은 코드 재사용성을 위한 개념이다.     
    일반적으로는 객체 두 개가 있다면 같은 기능을    
    하더라도 각각 중복되게 코드를 작성하는 것이     
    일반적일 것이다. 하지만 상속을 이용하면    
    중복되는 코드만 추출해 부모 클래스로 만들고,      
    부모 클래스를 상속 받아 부모 클래스의 코드를    
    재활용 하는 것을 말한다.      
    
    이렇게 되면 같은 코드의 중복을 없애면서도       
    자신의 상태와 기능은 유지하고, 중복되는    
    코드만 부모 클래스를 통해 사용하면 되는 것이다.      
    
    해서 상속을 다른 말로, 확장이나 진화라고도 표현한다.     
    부모 클래스의 모든 것을 자신의 것 처럼 사용할 수 있으면서     
    자기 자신은 고유의 상태와 기능을 가질 수 있기 때문이다.    
    
    자식 클래스가 상속을 받는 방법은 extend 부모클래스 해주면 된다.     
    이렇게 되면 부모 클래스를 상속 받게 되고, 따로 부모 클래스 인스턴스를      
    통하지 않아도 부모 클래스의 상태와 기능에 접근할 수 있다.        
    
    이 때 궁금한게 생긴다. 몇 가지 집고 넘어가보자.
    
    1. 어떤 타입으로 인스턴스를 생성해야 하는가?      
    2. 생성자 초기화는 어떻게 되는가?       
    3. 인스턴스 없이 부모 클래스에 어떻게 접근 하는가?     
    4. 부모와 자식 모두 서로 접근이 가능한가?      
    5. is - a 관계란 무엇인가?       
    6. 상속관계에서의 캐스팅은 어떻게 되는가?       
    7. 상속 vs 컴포지션, 4 가지 관점에 따른 차이    
***
1. 인스턴스의 경우 부모든 자식이든 상관 없다. 하지만 차이는 분명히 있다.     
   상속 구조가 내부를 들여다 보면 자식 클래스가 부모 클래스를 포함하는       
   구조로 되어 있다. 왜냐, 자식은 부모 클래스의 모든 것을 받으면서도     
   자신 고유의 상태와 기능을 가지기 때문이다. 그렇기에 차이가 발생한다.     
   부모 클래스 타입으로 참조변수를 선언해 인스턴스를 생성하면 부모 자신의     
   필드와 메서드에는 접근이 가능하나, 자식 클래스 타입을 참조해도, 자식 클래스에는    
   접근이 불가능 하다. 이유는 부모는 자식 클래스를 알 수 있는 방법이 없다.     
   상속 받은 자식 객체는 부모를 알고 있지만 부모는 단지 누군가가 자신을 상속받을 뿐이고,     
   그 밖에는 알 수가 없다. 그렇기 때문에 접근이 불가능하다.    
   
   반대로 자식 클래스 타입에 자식 클래스 타입 인스턴스를 생성하면,     
   자신의 상태와 메서드는 물론 부모의 상태와 메서드에도 접근할 수 있다.    
   이유는 자신이 상속 받는 대상이기 때문에 따로 부모 인스턴스 없이도 접근 가능하기 때문이다.     
   메모리상에도 자식 타입을 new 해 동적할당을 하는 순간 부모 객체를 저장할 수 있는 공간도     
   같이 생긴다. new 한 번에 상속 관계에 있는 모든 객체를 생성하지만 메모리 공간은     
   하나만 할당하고, 해제 역시 하나만 진행하게 된다.     
   그렇기 때문에 자식 입장에서는 자유롭게 부모 클래스에 접근할 수 있는 것이다.         
   
2. 생성자 초기화는 new 동적할당시에 초기 객체의 상태를 정하는 것으로 따로 부모 클래스를    
   생성하지 않기 때문에 부모 클래스에 매개변수가 있는 생성자가 있다면     
   항상 상위에 있는 부모 클래스를 먼저 초기화 해주어야 한다.     
   만약 부모 클래스에 정의한 생성자가 없다면 궂이 자식 클래스에서 생성자를 통해        
   초기화 해주지 않아도 컴파일러가 자동으로 매개변수 없는 생성자를 만들어 초기화를 진행한다.      
   부모 클래스에 정의 된 생성자가 있을 때만 자식 생성자에서 super(부모 생성자에 매개변수 전달)로      
   부모 클래스를 초기화 해주면 된다. 이렇게 하기 위해선 외부에서 부모 클래스의 생성자를 초기화 하는데    
   필요한 데이터를 자식클래스 생성자를 통해 받아와야 한다.     
   
3. 인스턴스 없이 부모 클래스에 접근하는 방법은 자식 클래스 내부에서는 super 로 접근하고,     
   자식 클래스 인스턴스로는 그냥 .(도트연산자)를 통해 접근하면 된다.     
   이게 가능한 이유는 상속을 통해 자식 객체를 생성할 때 부모 객체에 대한 정보를 이미 알고    
   있기 때문이다. 메모리 영역 역시 따로 참조를 가지는 것도 아니고 그냥 같은 공간을 사용한다.      
   하나의 메모리 공간에 부모 객체도 같이 있는 것이다. 그렇기 때문에 자식 객체에서는 아무런    
   제약 없이 접근이 가능하다. 물론 부모 클래스의 필드와 메서드가 private 이라면 접근이    
   불가능 하지만 그 외 접근제어자에서는 모두 접근 가능하다. (default 인 경우 같은 패키지에서만     
   접근 가능하다)    
   
4. 부모 자식 모두 접근 가능한가에 대해서는 3번에서 말한 내용이랑 겹치기 때문에      
   길게 작성하지는 않겠다. 부모에서 자식은 불가능하다. 이유는 부모 입장에서는    
   자식의 존재를 알 수 있는 방법이 없다. 인스턴스를 생성하지 않는 이상 접근 불가능하다.     
   자식의 경우 인스턴스 생성시에 부모 객체를 포함해서 인스턴스를 생성한다. 즉 하나의     
   메모리 블럭에 같이 저장하는 것이다. 그렇기 때문에 자식 입장에서는 자유롭게 접근 가능하다.    
   
5. is - a 관계란 상속 구조에서 ~ 는 ~ 이다. 라는 명제가 참인 경우를 말한다.      
   이런 경우 대부분 상속 구조로 나타낼 수 있다. 예를 들어 사람은 포유류이다.       
   이런 명제는 참이고, 이 경우 포유류들만의 공통점을 사람이 상속 받을 수 있다.    
   새끼를 낳는다는 공통점이 있고, 사람은 포유류를 상속 받으면서도 고유의 상태와     
   기능을 가질 수 있다. 이게 상속 구조이고, 포유류가 부모, 사람이 자식 클래스가 된다.      
   상속 구조를 생각하기 힘들 땐 일단 구체적인 클래스를 설계를 하고,     
   공통점을 뽑아 볼 수도 있고, 이런 is - a 관계를 생각해 상속 구조를 설계할 수도 있다.     
   
6. 상속관계에서 캐스팅에 대해 설명해보겠다. 일단 캐스팅이란 형변환을 말하는 것이다.     
   위에서 말했듯이 부모 클래스 타입 참조변수 = new 자식 클래스 타입();      
   5 번의 예를 좀 더 살펴보면 is - a 관계는 사람은 표유류이다를 코드로 표현하면      
   포유류 참조변수명 = new 사람(); 이게 된다. 즉 사람은 표유류이기 때문에 포요류에    
   대입 하는게 가능하다. 자식 클래스는 부모 클래스를 알고 있다. 특정할 수 있다.       
   그렇기 때문에 위와 같은 코드는 가능하다. 하지만 그 반대는 불가능하다.     
   단순 논리적으로 봤을 땐 포유류는 사람이다?? 말이 안된다. 모든 포유류가 사람이라는게     
   말이 안되기 때문에 불가능 하다. 또, 부모 클래스 타입은 여러 자식 클래스 타입을 참조할 수 있다.     
   이 때 자식클래스를 참조한 부모 클래스가 다시 다른 자식에 대입하려고 한다면?      
   전혀 연관 없는 클래스에 대입하는 것은 안되기 때문에 애초부터 보여지는 타입으로만 판단을 한다.        
   
   물론 명시적으로는 가능하다. 자식 클래스를 참조하고 있는 부모 클래스 참조변수가      
   같은 자식 타입 참조변수로 명시적으로 형변환 하는 것은 가능하다.      
   이 때는 부모가 참조하고 있는 자식과 자식의 참조변수 타입이 일치할 때만 런타임 오류 없이      
   대입이 가능하다.    
   
   그리고 자식과 자식간에는 명시적 형변환도 불가능 하다. 부모를 자식에 대입할 땐 명시적 형변환을      
   해 줬다. 자식을 부모에 대입할 수 있고, 명시적으로 캐스팅 해준다면 그 타입이 맞을수도 있고,    
   맞지 않는다면 런타임시에 에러가 날 테니까! 하지만 자식과 자식은 애초에 다른 클래스이므로,    
   캐스팅이 불가능하다. 
   
7. 상속과 컴포지션 선택 시 4가지 기준      
   일단 컴포지션이란 쉽게 말해 필요한 객체를 자신의 필드로 갖는 것을 말한다.     
   그럼 4가지 기준에 따라 상속과 컴포지션을 나눠 보겠다.    
   
   * 성능       
     메모리 관리 측면에서의 성능이다. 이는 인스턴스 생성 과정에서 어떻게 메모리를     
     할당하는지, 또 cpu 와 메모리가 일하는 방식으로부터 차이가 난다.      
     일단 상속 관계에 있을 때 객체를 생성하면 우리가 느끼기에는 부모 객체 하나    
     자식 객체 하나 이렇게 두 개가 생성되는 것 같다. 데이터 초기화도 가능하고,    
     객체에 자유롭게 접근 가능 하며 고유의 데이터를 가지니까. 하지만 메모리에서는    
     하나의 연속된 공간만 할당한다. 즉 자식 객체와 부모 객체가 서로 떨어져 있지    
     않다라는 것이다. 하나의 블럭에 전부 저장되게 된다. 그렇기 때문에 캐시 메모리에    
     저장될 때도 한 덩어리로 저장되게 되고, 일을 처리할 때 효율적이 된다.    
     
     하지만 컴포지션의 경우 어떤 식이든 new 동적할당을 객체의 수만큼 진행해야 한다.    
     그럴 때마다 파편적인 메모리가 객체마다 생겨나게 된다. 이는 String, enum 의 경우도       
     마찬가지이다. 쨋든 객체를 필드로 들고 있으면 생성자에서든, 필드에서든 직접    
     객체를 생성해 초기화 해야 하기 때문에 메모리의 참조값을 가지게 되고, 파편적으로     
     메모리를 사용하게 된다.     
     이렇게 되면 캐시메모리에 저장할 때도 관련 객체들이 한 번에 메모리에 올라가는 것이 아니라       
     여러번 왔다갔다 하면서 캐시 메모리에 올라갈 수 있다. 이 자체가 상속 보다는 비효율적이다.     
     
     해서 만약 성능이 정말 중요하다면 컴포지션 보다는 상속을 고려해 볼 수 있을 거 같다.     
     물론 얼마나 차이가 날지는 모르겠지만 말이다.    
     
     
   * 유지보수성           
     이 부분도 여러 관점에서 볼 수 있다. 일단 상속이 유리한 쪽으로 한 번 봐보겠다.     
     컴포지션의 경우 구현의 중복은 피할 수 있어도 시그니처의 중복이 생길 수 있다.     
     즉 같은 일을 하는 메서드가 두 개 생길 수 있다는 점이다.        
     이름을 바꾸는 역할을 하는 메서드가 외부 객체에 있는데 실제 이름은 내부 객체가     
     가지고 있다면? 이런 경우에는 changeName() 메서드 안에서 내부 객체의 changeName()      
     메서드를 또 호출해야 하는 경우가 생긴다. 이럴 경우 조금 애매해진다.     
     
     하지만 상속의 경우 완벽한 코드 재사용을 제공한다. 부모클래스에 있는 상태와 메서드는     
     그냥 가져와 사용하면 된다. (접근 제어자가 private 이 아닐 때)         
     그냥 자식 인스턴스로 자신의 필드와 메서드에 접근하듯이 사용하면 된다.      
     정말 자식클래스 내부 메서드에서 부모 클래스를 호출할 땐 super 키워드를 사용하지만     
     그렇다고 뭔가 구현이 겹치거나, 시그니처가 겹칠일은 없다.     
     
     하지만 상속에도 단점이 있다. 상속이 깊어지면 깊어질수록 부모 - 자식간의 결합도가     
     강해지고, 부모의 수정이 자식에게 어떤 영향을 줄 지 예측하기가 힘들어 진다.      
     그렇기 때문에 상속이 깊어지면 컴포지션과 다형성을 이용해 이 문제를 해결하기도 한다.     
     이렇게 상속의 단계가 깊어지면서 발생하는 문제에는 컴포지션이 좋은 대안책이 될 수 있다.      
     객체를 조립하는 개념이 컴포지션이고, 의존도를 낮추면서 유연성을 높힐 수 있기 때문이다.
    
    
   * 다형적 기능 이용    
     이건 상속만 가지는 고유한 기능이자 강력한 기능이다. 다형적 기능이란 하나의 타입으로         
     여러 타입을 참조할 수 있는 것을 말한다. 기본적으로 이는 불가능 하다. 하지만 예외적으로     
     상속 관계나 구현 관계에 있어서는 클래스간의 관계가 만들어지기 때문에 이게 가능하다.      
     하나의 부모를 상속 받는 자식 클래스들은 부모 클래스 타입의 참조변수에 의해 참조가 가능하다.     
     이렇게 되면 장점이 타입이 정해지지 않은 상태에서 런타임시에 타입이 유동적으로 결정될 수 있으며     
     이로 인해 전체적인 프로그램의 유연성이 올라가게 된다.
     
   
   * 일반적인 경우       
     위 특수한 경우를 제외 하고는 어쨋든 상속이든 컴포지션이든 사용이 가능하다.     
     이 때 이를 결정할 수 있는 가장 강력한 기준은 is - a 관계인지, has - a 관계인지     
     살펴 보는 것이다. 객체를 먼저 설계할 때 객체와 객체간의 관계가 어떤지에 따라      
     상속으로 구현할 지 컴포지션으로 구현할 지가 나뉘게 된다.     
     
     포유류는 동물이다(is - a, 상속으로 구현), 학교는 학생을 가지고 있다.(has - a, 컴포지션 구현)     
     이렇게 관계에 따라서 상속과 컴포지션을 결정하는 것이 가장 일반적이다.        
     그래야 주관적인 객체지향 설계에서 모두가 납득할 수 있는 설계가 나오게 된다.        
     
     컴포지션의 사용예로 엔티티 컴포넌트라는 유니티의 객체 구현 방법에 대해 간략히 소개하려 한다.      
     게임에서 각 캐릭터 마다 고유의 행동들을 이것 저것 조합하면서 테스트 할 때 사용하는 부분인데       
     게임 오브젝트 라는 최상위 클래스가 있고, 이 클래스는 컴포넌트라는 클래스를 가지고 있다.     
     이 때 리스트 형태로 가지고 있게 되고, 이 컴포넌트 클래스를 각각의 행동 클래스들이      
     상속 받은 형태로 되어 있다. 해서 게임 오브젝트 객체를 생성 하고, 게임 오브젝트 클래스에     
     있는 리스트 객체에 해당 오브젝트 케릭터로 테스트 할 행동들을 넣어주는 것이다.      
     이게 가능한 이유는 각 행동 객체들은 컴포넌트 클래스를 상속 받았기 때문에 다형적 기능으로     
     이게 가능한 것이다. 이렇게 컴포지션을 통해 객체들을 조립하듯이 사용할 수 있다.    
     필요한 것만 넣다 뺏다 하듯이
***
클래스를 재사용할 때 주의해야 할 것은     
1. 정말 재사용할 수 있는지 따져봐야 한다.     
   억지로 재사용 하는 것이 아닌지, 맞지 않는 클래스를    
   단순히 몇 개의 기능이 겹친다고 재사용 하는 것은 아닌지     
   잘 따져보고 재사용 해야 한다.      
   
2. 수정하지 않을 수는 없다. 항상 작성과 동시에 레거시가 된다.      
   이점을 알고 있어야 한다. 한 번 만들어둔 부모클래스는 수정하지     
   않는 것이 아니다. 왜냐, 항상 구체적인 것을 먼저 만들고 거기서    
   중복 되는 것들을 뽑아 부모 클래스로 만들기 때문에, 추상화 하기    
   때문에 어떤 부분이든 추가 되는 부분에 있어서 수정이 불가피하다.     
   
3. 장점에 예외가 없는 것은 아니다. 항상 어떤 상황이든 예외가 있다.     
   실버불릿은 없다. 상황에 맞게 유연하게 대처하는 연습을 해야 한다.     
