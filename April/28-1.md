# 밀린 공부한 내용 정리    
* 엄청 밀려 있는 내용을 한 번 정리 해봐야겠다.    
* 오늘 정리할 내용은 함수, 열거형, assert,     
  상속 이렇게 정리해 보겠다.      
  이렇게 정리하면 일단 배운 내용은 다 정리한 듯?     
***      
* 자 일단 함수를 정리 해봐야겠다. 지금은 C#을 기준으로 배우고 있고,    
  이번 정리는 함수 자체에 대한 정리이니 함수의 시그니처에 좀 더 초점을    
  맞춰 정리를 해봐야겠다.         
  
  일단 함수란 무엇인가? 그리고 함수는 왜 사용하는가? 그리고 함수의 구성과     
  만드는 방법, 함수의 범위, 잘 사용하는 방법 순으로 알아보면 좋을 듯 하다.     
  
  1. 함수란 무엇인가?     
     함수란 특정 기능을 수행하는 구문의 집합이라 볼 수 있다.     
     더하기 라는 함수는 더하는 기능을 수행하기 위해 필요한 구문들을    
     모아두고, 입력과 출력으로 더하기 라는 기능을 수행한다.     
     여기서 한 발 더 나아갈 수 있을 거 같다. 함수는 입력과 출력이 있는    
     혹은 둘 다 없어도 되는 특정 기능을 수행하는 것을 말한다.    
     
  2. 함수는 왜 사용하는가?     
     일단 함수 없이 프로그래밍 하는 것은 불가능 하다고 볼 수 있다.      
     우리가 출력하기 위해 사용하는 Console.WriteLine(); 역시 함수이고,       
     만약 이 함수가 없다면 우리는 화면에 문자열 하나 출력하기 위해    
     main 메서드에 수십줄의 코드를 작성해야 할 수도 있다.      
     만약 입력을 받으려면?? 어휴 상상하기도 싫다.     
     그러면 여러 줄을 출력 하려면 매번 수십줄을 중복해야 한다.      
     이 때문에 함수가 나온 것이다. 중복되는 코드를 하나의 함수로     
     만들어 재사용성을 높히기 위함이다.     
     Console.WriteLine(); 함수를 어디선가 만들어 놨기 때문에    
     우리는 라이브러리로 부터 함수를 호출해 재사용할 수 있다.      
     함수는 코드의 중복을 줄이고, 재사용성을 높히기 위해 사용한다 볼 수 있다.      
     
  3. 함수의 구성과 만드는 방법     
     일단 함수안에 함수는 원칙적으로는 불가능 하다.       
     main 메서드도 함수이기 때문에 main 메서드 안에      
     함수를 만드는 것은 불가능 하다.      
     그래서 main 메서드와 동일한 계층인 클래스 밑에서     
     함수를 만드는 것이 보통적이다.      
     ```C#       
     static int Plus(int first, int second)
     {
        return first + second;
     }
     ```
     자 함수를 만들어 보았다. 설명하기전에 static은 신경쓰지 말자.      
     일단 함수는 <반환타입><함수명><(매개변수 타입 매개변수명, 복수일 때 ,로 구분)>    
     이렇게 시그니처가 된다.      
     
     반환타입 부터 설명하면 반환타입이란 이 함수의 출력하는 값의 타입이다.      
     즉 이 함수가 어떤 값이든 반환을 할건데            
     이 때 반환하는 값의 타입은 위 반환타입에 명시된 타입이다.         
     반환타입이 있다면 무조건 return 을 통해 반환을 해야 한다.     
     반환타입이 있다고 했는데 아무것도 반환 하지 않으면 이상하지 않는가?
     만약 반환타입이 없다면 void 를 적어주면 된다. void 의 의미는     
     반환타입이 없다는 것이다. 반환타입이 없다고 안 적으면 안된다.     
     무조건 적어줘야 하고, 반환타입이 없을 땐 void 를 적어주면 된다.     
     
     함수명은 말 그대로 함수명이다. 즉 외부에서 이 함수를 호출할 때      
     이 함수명을 통해 호출하게 된다. 위 함수에서는 Plus 이고,      
     Console.WriteLine(); 에서는 WriteLine 이다.      
     이 함수명을 잘 지어야 한다. 함수는 기능이기 때문에 동사 형태로     
     함수명을 지으며, 이 함수명만 보고도 어떤 기능을 하는지      
     잘 나타날 수 있도록 최대한 잘 지어야 한다.       
     
     그 다음은 매개변수이다. 매개변수는 함수를 호출하는 쪽으로 부터      
     함수의 입력값을 전달 받는 변수이다. 함수 내부에서 기능을 수행하기     
     위해 필요한 입력값을 매개변수를 통해 전달 받고, 이 매개변수를 이용해    
     기능을 수행하고 return 을 통해 출력값을 반환하는 것이다.     
     매개변수는 0개 이상 선언 가능하고, 함수의 지역변수로써 기능을 하게 된다.      
     매개변수를 선언할 때 역시 이름을 잘 지어야 한다. 어떤 목적으로 값을 받을건지     
     호출하는 쪽에서 명확히 알 수 있도록 해야한다.       
     
     반환타입 함수명 매개변수를 모아 함수의 시그니처라 한다.        
     이 시그니처를 통해 함수를 호출하는 쪽에서 함수에 대해     
     명확히 알 수 있도록 해야 한다. 어쨋든 함수는 기본적으로      
     블랙박스라는 전제를 하기 때문이다. 입력과 출력이 있고,    
     내부 구현은 어떻게 되어 있는지 모르지만 시그니처를 통해       
     예상하는 결과를 얻기 위해 매개변수에 맞는 값을 입력하고,     
     기대하는 출력값을 얻어야 하기 때문에다.    
     
     이런걸 함수의 선조건, 후조건이라 한다.      
     함수의 선조건이란 함수가 실행 전 참이라고 가정한 조건이다.    
     즉 매개변수로써 이 선조건을 가정하게 된다.     
     매개변수 타입과 매개변수명에 의거한 알맞는 값을 넘겨주면    
     선조건이 충족된 것이다.     
     후조건은 너가 선조건을 충족시켰으니 예상하는 값을 반환할께     
     라는 것이다. 이 후조건에 해당되는 것은 반환타입과 함수명이다.      
     함수를 호출하는 쪽은 반환타입과 함수명을 보고 이 함수가    
     어떤일을 할 지 예상하게 되고, 선조건을 충족해 함수를 호출하게 된다.    
     이 때 후조건에 반하지 않도록 알맞는 반환을 하는 것이 함수의 책임이다.    
     그렇기 때문에 함수명을 잘 지어야 한다. 어떤 값을 리턴할 지, 어떤 기능인지     
     최대한 잘 나타날 수 있는 동사 형태의 이름을 지어야 한다.    
     
  4. 함수의 범위     
     기본적으로 함수는 독립적이다. 그렇기 때문에 함수 내부에 선언된    
     변수는 해당 함수에만 국한된다. 즉 함수는 자신의 범위를 가진다는 것이다.      
     이를 scope 라고도 하는데 함수끼리는 scope 간섭을 하지 않는다.    
     가장 햇갈리는 것이 매개변수로 주고 받는 변수이다.    
     ```C#     
        static void Main(String[] args) 
        {
          int a = 1;
          int b = 2;
          int c = Plus(a, b);
          
          Console.WriteLine(a);
          Console.WriteLine(b);
          Console.WriteLine(c);
        }
        
        static int Plus(int a, int b)
        {
          a += 1;
          b += 2;
          return a + b;
        }
     ```
     위와 같은 경우 Main 메서드의 정수 a, b 를 Plus 함수에 넘기고,    
     Plus 함수 내부에서 a 에는 1, b 에는 2 를 더했다.    
     그리고 이 둘을 더한 값을 반환하고 있다. 하지만 Main 메서드에서    
     출력한 결과값은 a = 1, b = 2, c 만 Plus 함수의 return 값을 받아      
     6를 출력하게 된다. 즉 Main 메서드의 a, b 의 값은 변하지 않았다.     
     
     이렇게 되는 이유는 각 함수는 고유한 영역을 가지고, 변수명이 같아도     
     그냥 동명이인으로 생각하면 된다. 이름이 같다고 같은 사람이 아니듯이     
     Main 에 선언 된 a, b 와 Plus 의 매개변수인 a, b는 다른 변수이다.     
     전혀 연관성이 없다.       
     
     이러한 현상을 값에 의한 복사라고 해서 call by value 라고 한다.    
     즉 호출하는 쪽의 원본은 유지된채로 값만 복사되서 전달되는 것이다.      
     그렇기 때문에 Plus 함수 내부에서 값을 변경해도 Main 메서드 내부의     
     변수들에는 영향이 없었던 것이다.      
     
     참조에 의한 복사도 있다. call by reference 라고 하는데 이경우엔      
     원본 값이 바뀌게 된다. 즉, Main 메서드에서 a, b 를 전달하고,      
     Plus 함수에서 a + 1, b + 2 하게 되면 원본의 값이 바뀌는 것이다.      
     이렇게 참조에 의한 복사를 하려면 ref 라는 키워드를 통해 진행할 수 있다.          
       ```C#     
        static void Main(String[] args) 
        {
          int a = 1;
          int b = 2;
          int c = Plus(ref a, ref b);
          
          Console.WriteLine(a);
          Console.WriteLine(b);
          Console.WriteLine(c);
        }
        
        static int Plus(ref int a, ref int b)
        {
          a += 1;
          b += 2;
          return a + b;
        }
     ```     
     위 같이 호출하는 쪽과, 매개변수에 모두 ref 를 넣어주면 참조에 의한 복사가     
     진행되고, Plus 함수 내부에서 더해주는 값이 원본에 그대로 반영이 된다. 해서    
     출력 값은 a = 2, b = 4, c = 6 이 되는 것이다. 원본이 바뀌기 때문에.     
     
     그리고 범위에 대해 좀 더 얘기하자면 함수 안에서도 중괄호가 있는 곳에는     
     범위가 적용이 된다.     
     ```C#      
     static void Main(String[] args)
     {
        int a = 10;
        
        for(int i = 0; i < 10; i++)
        {
            a += i; // 이 경우 a 사용 가능, 상위 범위 -> 하위 범위 가능
        }
        
        i = 100; // 이 경우 불가능. 하위 범위 -> 상위 범위 불가능      
                 // 조건문 내부에서 역시 해당된다.             
     }
     ```
     이렇게 상위범위에서 선언된 변수는 하위 범위에서 사용 가능 하지만     
     하위범위에서 선언된 변수는 상위범위에서 사용 불가능 하다.     
     이게 지역변수의 scope 이다.      
     
     함수는 정말 프로그래밍에서 필요한 존재이다. 하지만 이 역시 과유불급이다.       
     너무 자잘하게 모든 것을 함수로 만든다면 가독성이 떨어지고, 읽기 불편한    
     코드가 될 것이다. 그리고 내가 만들어 놓은 함수를 사용하는 사람들이 생기는데    
     추후 수정이 불가피한 함수라면 한 번 더 함수로 만드는 것을 재고해 볼 필요가 있다.     
***
함수만 정리 했는데 내용이ㅋㅋㅋ미쳤다.    
일단 자르고 열거형하고 assert 정리해야겠다.    
상속은 유튜브로??ㅋㅋㅋ
