# 오늘 공부한 내용 정리     
* 문자열, String에 대해서    
* String 클래스가 뭔가요?     
  String 클래스는 char[] + 필요한 메서드를    
  합쳐 놓은 클래스로 문자열들을 저장할 수 있는   
  클래스 입니다. 특징으로는 생성 시 new 키워드를   
  사용해 생성해야 하지만 일반 기본형 변수를 초기화   
  하는 것처럼 값을 대입하듯 사용할 수 있다는 점입니다.    
    
  하지만 그 내부는 완전히 다릅니다.     
  `String s = "ABC";` 이렇게 저장을 하게 되면    
  ABC라는 값을 가진 객체가 메모리 공간에 생성됩니다.    
  단순히 new 키워드를 사용하지 않았을 뿐이지    
  객체가 생성된다는 것은 같습니다.    
    
  또한 `String ss = "ABC";` 이렇게 같은 ABC 문자열을    
  생성한다면 하나의 새로운 객체가 생성되는 것이 아닌     
  이미 생성된 ABC 객체를 참조하게 됩니다.   
    
  해서 참조변수 s와 ss는 서로 같은 메모리 주소를 참조하며     
  `System.out.println(s == ss);` 를 출력해보면 `true`가     
  나오게 됩니다. 즉 같은 메모리 주소를 참조하고 있다는 사실을   
  알 수 있습니다. 값이 같은 문자열의 경우 새로 만들지 않고     
  기존의 문자열의 참조를 한다는 특징이 있습니다.     
    
  또한 문자열을 `+` 연산자를 통해 붙일 땐 기존의 문자열들을    
  읽어와, 이 둘을 붙인 새로운 문자열 객체를 생성하게 됩니다.     
  해서 기존 문자열 객체들을 그대로 유지한채로 새로운 문자열    
  객체를 만들게 되는 것입니다.      
    
  객체이기 때문에 아무런 참조가 없다면 GC에 의해 제거 되겠지만    
  그 전까지는 변경되지 않고 읽을수만 있는 객체가 되어 메모리상에     
  존재하게 됩니다. 그렇기 때문에 문자열을 더해도 새로운 문자열   
  객체가 만들어지고, 참조가 끊기지 않는한 기존 문자열을 유지하는 것입니다.      
    
* 그럼 String 문자열 비교는 어떤식으로 하나요?    
  기본적으로는 == 비교나 equles() 비교 둘 다 가능합니다.     
  같은 문자열이라는 기준하에 둘 다 true 가 나오는 것은 동일합니다.    
  어쨋든 같은 문자열이면 같은 메모리 주소를 참조하고 있기 때문입니다.   
  
  하지만 new String() 을 통해 생성자에 값을       
  넣어주는 식으로 문자열을 생성하면 같은 문자라도     
  다른 메모리 주소를 반환하게 됩니다.     
  즉 다른 문자열 객체가 됩니다.    
  그렇기 때문에 이런 경우에는 equles() 사용 해야 합니다.      
  
  == 비교시 객체의 메모리 주소를 비교하게 되며      
  new 키워드로 생성된 객체의 메모리 주소는 서로    
  다르기 때문입니다.   
  
  정리하면 일반적인 대입으로 생성한 문자열의 경우    
  객체로 생성되지만 같은 문자열이면 하나만 생성되고,     
  참조값만 같은 객체를 참조하지만 new 키워드로 생성된    
  문자열의 경우 같은 문자열이라도 서로 다른 메모리 주소를   
  가지고 각각 생성된다는 걸 알 수 있습니다.      
  
  또한 대입형 생성의 경우 == 이나 equles() 비교 모두 true 지만    
  new 키워드 생성의 경우 == 은 false 가 나옵니다. 메모리 주소를    
  비교하기 때문입니다. equles의 경우 역시 메모리 주소를 비교하지만    
  String 문자열의 경우 값을 비교하는 것으로 보입니다. 내부적으로    
  equels 메서드를 오버라이딩 해 구현 했기 때문입니다.     
  
* equals() 메서드를 오버라이딩 하지 않으면 어떻게 되나요?    
  기본적으로 equals 메서드 역시 Object 클래스의 메서드이고,    
  객체의 메모리를 비교합니다. 하지만 서로 비교하는 클래스에서    
  equals 메서드를 Object 클래스로부터 오버라이딩 해 구현한다면    
  기준이 되는 값을 비교하도록 할 수 있습니다.    
  
  String의 경우 내부적으로 이미 구현이 되어 있기 때문에      
  그냥 객체를 집어 넣어도 문자열을 비교할 수 있는 이유입니다.      
  
  하지만 개발자가 직접 만든 클래스의 인스턴스는 equals 메서드가      
  오버라이딩 되어 있지 않다면 객체의 주소를 비교하기 때문에     
  원하는 결과가 나오지 않을수도 있습니다. 해서 내가 비교하고자    
  하는 값으로 비교할 수 있도록 equals 메서드를 오버라이딩 해 구현    
  하거나, 비교할 때 값에 접근해 비교할 수 있도록 해야 합니다.     
  
  하지만 값에 직접 접근 하는 것은 캡슐화 관점에서 좋지 않기 때문에    
  필요하다면 equals 구현 하는 것이 좋을 거 같습니다.    
  
  그리고 번외로 Object 메서드를 형변환 할 땐 instenceOf 키워드를    
  이용해 변환 하려고 하는 타입의 객체인지 확인을 해주고 변환해야 합니다.    
  Object의 경우 어떤 클래스든 변환이 가능하기 때문에 내가 비교하고자    
  하는 객체가 잘 전달 됬는지 확인하는 작업이 필요합니다.        
  instenceOf 는 매개변수로 입력된 객체가 비교하는 객체와 같은 타입인지 부터    
  부모, 조상까지 포함관계에 있는 객체까지 비교할 수 있습니다.     
  자신의 타입이나 인터페이스, 추상 클래스를 상속 받았다면 true,     
  아예 관계가 없을때만 false를 반환하는 키워드 입니다.       
  `매개변수로 전달된 객체 instenceOf 비교 타입, 클래스`      
  이렇게 사용하게 됩니다.            
  
* String 문자열이 불변인 이유는 대입 연산자를 통해      
  문자열을 생성해도 실행시에 new String("생성한 문자열")    
  이렇게 저장이 되고, 상수 풀에 저장이 된다.    
  상수는 값의 재할당이 불가능 하기 때문에 String 문자열 역시    
  값이 변경될 수 없는 것이다. 그렇기에 여러 참조변수가    
  하나의 객체를 참조해도 값이 변경될 일이 없기 때문에   
  안전한 것이다. 읽기만 가능하다.      
  
  '+' 를 이용해 새로운 문자열을 만들 때도 문자열을 합치게 되면     
  기존의 문자열 객체는 그대로 유지된 채 합쳐진 문자열 객체가    
  새로 생성되어 참조를 하게 되는 것이다. 그렇기 때문에      
  자주 '+' 를 이용해 문자열을 붙이면 매번 객체를 생성하게     
  되는 것이고, 이는 효율을 떨어뜨리게 된다.     
  
  for문을 돌면서 계속 문자열을 '+' 로 붙이게 되면    
  그 수 만큼 객체가 생성될 것이니, 속도도 느리고,   
  메모리 낭비도 심해지게 될 것이다.         
  
* 빈 문자열의 경우 역시 "" 가 가능한 이유는 크기가 0인 char[]을    
  생성한다는 의미와 같기 때문이다. 해서 String의 경우 ""가 가능하고,     
  char의 경우 ' ' 이렇게 빈 문자열을 만들어 초기화 해야 한다.    
  
  String의 경우 "" 를 한다면 크기가 0인 char[]을 생성 하게 된다.     
  그리고 또 다른 String 참조변수가 "" 를 한다면 이미 생성된    
  "" 객체를 가르키게 된다. 이게 String에서 대입을 사용해      
  값을 초기화 해야 하는 이유이다. 같은 값에 대해서는 같은 객체의    
  참조값을 가지기 때문.     
  
  new 해서 생성하지 말자. 이렇게 생성하게 되면 같은 문자열이라도      
  계속 다른 객체를 생성하기 때문이다.        

정리 : 기본적으로 문자열은 내용을 변경할 수 없다.         
       그래서 같은 값을 사용할 땐 새로 생성하는 것이 아닌       
       기존에 생성된 값을 그대로 사용할 수 있도록 한다.       
       즉, 문자열이 생성된다는 것은 객체가 생성된다는 것이고,      
       한 번 생성된 문자열 객체는 변경이 불가능하다.      
       그래서 생성된 문자열을 재사용 할 수 있도록          
       같은 값이면 객체를 생성하지 않고, 이미 생성된       
       객체의 메모리 주소를 참조할 수 있게 된다.      
       위 경우에는 대입연산자 = 을 사용했을 때 얘기이다.      
       new 키워드를 통해서도 문자열 객체, String 객체를       
       생성할 수 있는데 이 경우엔 같은 문자열이라도         
       서로 다른 객체가 생성되기 때문에 특수한 경우가 아니면         
       String 문자열의 불변성을 활용할 수 있는 = 대입 연산자를        
       사용해 같은 값이 계속 생성 되는 것을 막고,         
       기존의 객체를 재사용 할 수 있도록 하자.             
