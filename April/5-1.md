# 오늘 공부한 내용    
* 키워드 : ArrayList, 오토박싱,      
  Array는 객체배열로 만들어진다.      
  remove시 이동, 배열의 복사.
***
* ArrayList - 배열 기반의 자료구조, 실제로 객체배열로    
  구현되어 있으며, 인덱스 번호를 가지고, 순서를 가진다.     
  내부를 보면 Object[]로 구현되어 있기에 int값을 넣고자     
  할 때 new Integer(1) 이렇게 넣어줘야 하지만 add(1) 해도 된다.     
  
  이유는 내부에서 자동적으로 오토박싱 해주기 때문이다.   
  즉 기본형인 1을 Integer(1) 로 변경해주기 때문.    
  
  List 인터페이스를 상속, 구현한 클래스가 ArrayList Class이다.     
  List 컬랙션의 특징은 순서를 가지고, 인덱스 번호를 가진다는 것이다.    
  인덱스 번호는 곧 순서를 의미하고, 인덱스 번호대로 저장되어 진다.    
  또 하나의 특징으로는 중복을 허용 한다는 것이다. 어짜피 순서대로    
  인덱스가 붙은 방에 객체를 저장하기 때문에 값이 중복되도 상관 없는 것이다.    
  
  ArrayList는 모든 값들이 전부 객체로 저장된다.   
  순서를 가지고(인덱스 번호를 부여해 순서를 표현),     
  중복을 허용한다. 저장되는 객체 고유의 공간을 할당하기 때문.    
  이유는 Object[] 로써 구현이 되기 때문이다.      
  
* 오토박싱이란 무엇인가?    
  오토박싱이란 기본형 자료형을 각 자료형의 wapper class로     
  변환 시키는 것을 말한다. 이 때 컴파일러가 자동적으로   
  wapper class로 변환 시킨다.     
  
  오토박싱의 예는 컬랙션에 기본형 값을 그대로 넣을 때이다.    
  `     
  ArrayList arr = new ArrayList();           
  arr.add(1);        
  `    
  이렇게 한다고 했을 때 1이라는 정수 값은 new Integer(1)로     
  오토박싱되어 컬랙션에 저장되게 된다.   
  기본적으로 ArrayList는 Object[] 로 이루어져 있으며,    
  객체로 저장되어야 하기 때문에 wapper class인 Integer로    
  바꿔 저장하게 되는 것이다.    
  
* 반대의 개념인 오토 언박싱도 있다.   
  이는 값을 꺼낼 때 오토 언박싱 되어    
  값을 꺼내게 된다.       
  즉 int 형으로 정수를 저장했다면,      
  ArrayList 내부에는 Integer(1)로 저장해두고    
  꺼낼 땐 int 형 정수로 변환해서 반환하는 것을   
  오토 언박싱이라 한다.    
  
  따로 `(int) arr.get(0);`     
  이렇게 형변환 해주지 않아도 된다.   
  자동으로 형변환 되어 반환 되는게    
  오토언박싱이다.    
  
* ArrayList의 삭제시엔 정수값을 주면 인덱스로 인식해    
  해당 인덱스의 객체가 지워진다. 내가 만약 특정 값을    
  주고 해당 값을 지우고 싶을 땐 객체를 넣어 주어야 한다.   
  즉 int형 정수를 지우고 싶다면        
  `    
  arr.remove(new Integer(1));     
  `       
  이렇게 해주면 된다. 그럼 1이라는 값을 가진 객체를   
  삭제하게 될 것이다.     
  
  기본형 정수 값은 인덱스를 표현한다. 기본적으로는    
  모든 값은 객체로 저장된다. 왜냐, Object[]로 저장되기 때문.       
  ArrayList가 Object[]로 표현되기 때문.

* 배열 기반의 ArrayList의 중간에 추가, 삭제를 하는 것은    
  부담이 가는 작업이다. 이유는 배열은 크기를 유동적으로   
  늘릴 수 없기 때문에 추가하고 삭제 위해서는 기존 배열을   
  복사 후 값을 추가, 삭제 후 다시 덮어서 복사를 하는    
  과정이 필요하다.     
  
  해서 잦은 추가와 삭제가 있을 땐     
  연결기반의 링크드리스트를 사용하는 것이다 좋다.    
  
* ArrayList의 값을 remove() 할 때 벌어지는 일,      
  지정한 인덱스의 값을 덮어쓰기 위해 그 뒤 배열의    
  원소들이 전부 한 칸씩 이동한다. 즉 한 칸씩 앞으로    
  값을 복사하게 된다.     
  
  그리고 맨 뒤에 값이 null로 변경하고(왜냐, 하나씩 복사해서     
  앞으로 땡겼기 때문에 맨 뒤에 값은 없어져도 된다.)     
  데이터의 갯수가 하나 줄어서 size가 줄었으므로 size를    
  size--; 를 통해 전체 배열의 개수를 조정한다.        
  
  만약 마지막 원소를 삭제할 땐 따로 복사할 것 없이   
  그냥 해당 원소를 null로 바꾸고 size만 -- 해주면 된다.    
  이유는 맨 마지막 이기 때문에 뒤에 있는 값을 땡겨올 필요가     
  없기 때문이다.     
  
* ArrayList 삭제 시 주의해야 할 것.      
  for문을 돌면서 모든 원소를 삭제하려고,    
  아무 생각없이 0번 부터 삭제한 경험이 있다.   
  하지만 나는 size()만큼 돌았으니 전부 삭제가    
  됬을거라 생각했지만 나중에는 IndexOutOfBound 에러가 났다.    
  가정은 size가 4, 인덱스가 0 ~ 3까지로 하겠다.
  
  이유를 봤더니 삭제 방식에서 오는 차이였다.    
  0번 인덱스의 원소를 지우면 한 칸씩 지워진다.    
  1번 인덱스를 지우면 0번 인덱스는 유지되고 2번인덱스의 값이    
  1번 인덱스로 이동되면서 기존 1번 인덱스의 값이 지워진다.     
  2번 인덱스를 지우면 3번 인덱스가 2번인덱스를 덮으면서    
  기존 2번 인덱스가 지워진다.     
  3번 인덱스를 지울 땐 3번 인덱스는 없다. 왜냐 2번 인덱스에 3번        
  인덱스 값을 덮어 씌우면서 한 칸 앞으로 이동했고, 3번 인덱스가   
  마지막 인덱스였기 때문에 그 뒤에 값은 없다.    
  
  해서 에러가 난다. 이렇게 앞으로 땡기면서 삭제를 진행하는    
  특성을 이해해야 한다. 순회하면서 지울 땐 뒤에서부터 지우면   
  아무 문제가 없다. 단 중간에서 값을 지우게 된다면 이점을       
  유의해야 할 거 같다. 그 다음 값은 현재 지우는 원소의     
  위치에 있는게 아니라 내가 방금 지운 인덱스에 위치 한다는 것을.     
  계속 앞으로 이동하기 때문에.
        
* 배열의 특징으로는(ArrayList가 결국 배열로 구현)    
  크기가 불변적이라는 것이다.        
  그렇기 때문에 원소를 추가하고자 한다면    
  더 큰 사이즈의 배열을 생성,          
  기존 원소를 옮긴 후 참조를 변경해주어야 한다.     
  이 과정은 ArrayList의 add() 메서드에서도 동일하게 발생한다.      
  배열을 사용한다면 이 같은 과정을 직접 구현해야 하지만     
  이를 편하게 사용하게 만들어 둔 것이 ArrayList class 이다.      
  
* 또한 위에서 봤듯이 추가, 삭제시에도 시간이 많이 걸린다.   
  데이터가 많아지면 많아질수록 더 오래 걸리는데 이는    
  모든 원소를 앞으로 이동해야 하기 때문이다. 모든 원소가 이동하면서    
  한 칸씩 앞으로 땡겨야 하기 때문이다.        
  
* 이런 배열의 단점을 보완하기 위해 나온 것이 링크드리스트이다.     
  링크드리스트는 불연속정인 특징을 가진다. 어잿든 리스트이니     
  연속적이지 않을까 생각했었는데, 배열에서의 연속적이라는 것의 의미는       
  인덱스가 붙어있는 각 배열의 공간들이 메모리 상에서도 연속적으로      
  붙어 있음을 의미한다. 해서 배열은 연속적인 특징을 가지는 자료구조이고,    
  링크드리스트는 각 원소들이 메모리상에 어디에 있는지 알 수가 없다.   
  정확히는 자신의 다음 원소의 위치(메모리 주소)만 알 수 있다.    
  해서 링크드리스트는 불연속적이라고 하는 것이다.        
     
  이렇게 자신의 다음 원소의 메모리 주소만을 가지고 있는 것을 표현하면    
  노드1 -> 노드2 -> 노드3 이런식으로 표현할 수 있다.     
  
  이렇게 서로 연결 되어 있는 것처럼 보이기 때문에      
  링크드리스트라 불린다.     
  
* 링크드리스트의 특징으로는 중간에 배열의 단점이었던 중간에 추가, 삭제가    
  훨씬 빠르다는 점이다. 이유는 내가 어떤 원소를 추가하고 싶다면     
  내가 추가하려는 인덱스의 이전 노드가 가르키는 다음 원소에 대한 참조값만   
  추가하는 노드의 메모리 주소로 변경해주면 된다.      
  
  그냥 연결만 바꾸면 된다. 노드1 -> 노드2 -> 노드3 이 그림에서     
  화살표만 노드 1 -> 추가하는 노드 -> 노드2 -> 노드3 이렇게      
  변경해주면 추가가 된다. 삭제 시에도 참조하고 있는 노드만    
  삭제하는 노드의 다음 노드로 참조만 변경해주면 아무도 참조하고 있지 않는   
  객체는 GC의 수거 대상이 되기 때문에 삭제가 된다.      
     
* 순차적으로 데이터를 읽을 때, 추가, 삭제할 땐    
  연결기반인 배열의 속도가 빠르다.   
  이유는 메모리 공간을 연속적으로 점유하고 있기 때문에      
  앞에서부터든, 뒤에서부터든 연속적으로 읽으면 된다.   
  또한 인덱스로 값을 찾을 때도 배열이 훨씬 빠르다.     
  이유는 아래 공식을 통해 바로 해당 데이터가 저장되어 있는     
  공간으로 접근해서 데이터를 읽어오면 되기 때문이다.    
  공식 : 배열의 메모리 공간 * 자료형의 크기 + 인덱스 = 해당 원소가 있는 공간        
  
  하지만 중간에 데이터를 삭제하거나 추가할 땐 링크드리스트가     
  빠른 모습을 보인다. 링크드리스트는 불연속적이기 때문에     
  연속적인 배열이 같는 장점은 단점으로 가지게 되지만      
  장점은 중간에 따로 값을 옮기거나 할 필요 없이 참조만 변경하면 되기 때문에     
  중간에 값을 추가, 삭제는 훨씬 빠르다고 볼 수 있다.     
  
  
