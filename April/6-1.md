# 오늘 공부한 내용 정리    
* 키워드 : 스택, 큐, empty, isEmpty 차이      
***       
* 스택이란?     
  스택이란 밑이 막힌 상자라고 생각할 수 있다.    
  데이터를 넣고 빼는 곳이 한 곳이며, 먼저 들어오면    
  가장 나중에 나가는 특징을 가지고 있다.    
  
  중간에 데이터를 넣거나 뺄 수 없고 오로지 한 곳을 통해    
  넣거나 뺄 수 있다.    
  Last In First Out 이라 해서 LIFO 구조라고 한다.     
  
* 큐란?    
  큐란 터널에 비유할 수 있을 거 같다. 특징은 앞과 뒤가    
  뚤린 상자이고, 스택과 반대로 데이터가 들어온 순서대로    
  나간다는 것이다. 입구와 출구가 1개씩 있으며, 먼저 들어온    
  순서대로 그대로 나가게 된다.    
  
  First In First Out 이라 해서 FIFO 구조라고 한다.     
  
* 스택의 경우 Vector 클래스를 상속받았기 때문에     
  `Stack s = new Stack();` 이렇게 선언해 사용한다.    
  Vector만 상속 받았기 때문에 위 같이 선언해도    
  상위 클래스의 모든 메서드와 필드를 사용할 수 있고,    
  Vector는 요즘 잘 사용하지 않기 때문에 다형성을    
  활용할 일도 적어서, 명확하게 Stack으로 선언해    
  사용하는게 나을 듯 하다.        
  
  다시한 번 스택은 밑이 막힌 상자 같은 자료구조이고,   
  데이터를 넣은 순서와 빼는 순서가 완전히 뒤바껴서    
  나오게 된다. 이러한 특징이 있다. 넣은 순서대로 빼는   
  것이 아니라 마지막에 넣은 데이터를 가장 먼저 뺀다.     
  
* 큐의 경우 인터페이스이다. 즉 Queue의 경우는 인터페이스   
  이기 때문에 이를 구현한 구현채의 객체를 생성해 대입해서     
  사용하게 된다. 이 땐 `Queue q = new 구현체();` 이렇게      
  생성해서 사용하는 것이 보편적이다. 애초에 Queue로는     
  인스턴스의 생성이 불가하기 때문이다.     
   
  대표적으로 Queue를 구현한 구현체로 LinkedList가 있다.    
  해서 `Queue q = new LinkedList();` 이렇게 선언해 사용    
  할 수 있고, Queue가 가지고 있는 모든 메서드를 사용할 수 있다.     
  
  다시한 번 Queue는 입구와 출구가 명확히 있는 자료구조이고,     
  들어온 순서대로 나간다는 것을 명심하자.     
  
* size() 메서드를 통해 for문을 돌릴 땐 size() 값을 미리    
  for문전에 호출해 값을 저장하고, 해당 값을 담은 변수를    
  사용하자. 왜냐하면 매번 size() 를 호출하는 것은 비효율    
  적이기 때문에 한 번만 호출해 값을 받아두고, for문에     
  사용하도록 하자.     
  
* Iterator 클래스는 Collection 클래스의 자손들은    
  List와 Set 인터페이스의 상위 클래스로, 그 자손     
  클래스들의 원소를 조회할 때 편리하게 조회할 수 있도록     
  만들어둔 공용 인터페이스이다.     
  
  사용법은 List나 Set 자료구조에 iterator 객체를 얻어올 수 있는     
  iterator() 메서드가 있다. 이 메스드를 가지고 iterator 객체를 얻고,       
  해당 객체의 hasNext() 메서드와 next 메서드를 가지고 원소를    
  조회하면 된다.       
  
  특징으로는 이 iterator 객체는 1회성으로 사용 가능하다는 것이다.    
  각 원소를 돌면서 하나하나 가르키고 데이터를 꺼낸다음 모든 데이터를   
  돌면 더이상 가르킬 데이터가 없기 때문에 hasNext() 메소드는 계속    
  false 를 반환하게 된다. 해서 다시 iterator 객체를 사용하려먼    
  다시 메소드를 통해 얻어와야 한다.     
  
  이렇게 Iterator 인터페이스를 만든 이유는 Collection 프레임워크에     
  하위 인터페이스인 List와 Set의 원소 조회에 일관성을 가지기 위해    
  만들어 졌다 볼 수 있다. 만약 Collection 인터페이스 타입으로      
  참조 변수를 선언하고, List나 Set 객체의 인스턴스를 할당 했을 때     
  타입이 Collection이기 때문에 List에서 Set으로, 또는 Set에서 List로   
  바뀔 때 아무런 변경 없이 확장성 있게 변경할 수 있다.    
  
  이런 이유로 인터페이스를 통한 추상화에 의존해 사용하는 것이다.      
  Iterator도 비슷한 이유로, 구현 클래스가 바껴도, 조회는 동일하게   
  진행하기 때문에 Iterator 객체를 사용한 코드는 변경하지 않아도 된다.    
  
* Map의 경우 Collection 프레임워크의 하위 클래스가 아니다. 그렇기에      
  Iterator 객체를 얻어올 방법이 없는데, 이 땐 keySet(), entrySet(),     
  values() 등의 메서들를 통해 Set, Collection 객체로부터 iterator 객체를    
  얻어와야 한다. 허나 대부분 Map을 사용할 땐 keySet()으로 키를 얻어와    
  foreach문을 통해 값을 조회한다.    
  
* 핵심은 Collection 프레임워크의 자손들만 Iterator 객체를 얻어와   
  조회를 할 수 있고, List와 Set이 자손에 해당한다.     
  이렇게 인터페이스를 사용하는 이유는 확장성을 가지기 위함이고,     
  인터페이스 타입으로 정의했을 때 인스턴스의 참조가 바뀌어도    
  같은 자손 클래스라면 그 어떤 변화 없이 변경이 가능하다.    
  
  결국 Collection 타입으로 선언 했을 것이고, Collection에    
  정의 되어 있는 메서드를 사용했기 때문에 참조를 다른    
  자손 구현체로 변경해도 따로 변경하지 않아도 된다.    
  Iterator도 이런 확장성 때문에 사용하는 것이다.    
  
* 이분탐색이란?    
  배열을 탐색할 때 절반을 나눠 검색하는 것을    
  이분탐색, 이진탐색이라 한다. 메서드로는     
  BinerySearch를 지원해 이분탐색을 한다.    
  배열이 0 ~ 9 까지 인덱스가 있으면 이를 먼저    
  반으로 나누고, 또 그 안에서 반으로 나눠 비교를 진행한다.    
  
  이렇게 하면 순차적으로 찾을 때 보다 검색 성능이 좋아진다.   
  이유는 만약 배열의 맨 끝에 있는 데이터를 찾아야할 때도      
  처음부터 하나씩 비교하면서 찾아가야 하는 반면에    
  이진 탐색은 범위를 좁혀 나가면서 데이터를 찾기 때문에   
  데이터를 비교하는 횟수가 적다.    
  
  하지만 이진 탐색을 이용하기 전에 꼭 해야할 일이 있다.   
  바로 정렬을 해야 하는데 이유는 정렬이 되어 있다는 기준하에   
  반으로 자르고, 찾고자 하는 데이터의 범위에 미치지 않으면    
  아예 버리기 때문에 정렬이 되어 있어야 한다.     
  정렬이 되어 있지 않으면 이상한 값이 나오게 된다. 반으로 잘랐는데   
  범위를 제대로 설정할 수가 없기 때문이다.     
